[{"title":"Java复习——从入土到入门","url":"/2021/05/14/JavaReview/","content":"# Java知识点概览：\n## Java的概念和特点：\n### 概念\n&emsp;&emsp;Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点， 还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。\n&emsp;&emsp;由上述介绍可知：\n&emsp;&emsp;&emsp;&emsp;1. Java是一门面向对象的语言\n&emsp;&emsp;&emsp;&emsp;2. Java是单继承的\n&emsp;&emsp;&emsp;&emsp;3. Java语法没有指针概念\n### 特点\n&emsp;&emsp;Java还有几个重要特点：\n&emsp;&emsp;&emsp;&emsp;1. Java是类型安全的\n&emsp;&emsp;&emsp;&emsp;2. Java是跨平台的\n### Java的JVM、JRE、JDK\n&emsp;&emsp;Java的<font color=orange><b>跨平台性</b></font>是区别于其他语言的显著特点：\n&emsp;&emsp;&emsp;&emsp;Java程序运行在<font color=red>JVM</font>(Java虚拟机)上，我们写的Java源代码通过javac命令编译成.class字节码文件，这个字节码文件可以在各个平台的JVM环境上运行。\n&emsp;&emsp;&emsp;&emsp;Java运行环境(<font color=red>JRE</font>)：光有JVM是不够的，Java还需要依赖一些类库，这些类库存在于JRE中，所以JRE包括两部分：JVM和类库\n&emsp;&emsp;&emsp;&emsp;Java开发工具包(<font color=red>JDK</font>)：作为开发人员，我们需要编译、调试Java程序，例如javac就存在于JDK中。\n&emsp;&emsp;&emsp;&emsp;所以，想要运行Java程序，借助JRE这个运行环境即可，而开发Java程序，需要JDK这个开发工具包。\n## Java基本语法\n### 数据类型\n&emsp;&emsp;Java的数据类型大体上可以分为2种：\n&emsp;&emsp;&emsp;&emsp;1. <font color=red>基本</font>数据类型\n&emsp;&emsp;&emsp;&emsp;2. <font color=red>引用</font>数据类型\n#### 基本数据类型：\n&emsp;&emsp;和C语言类似：Java也有整型、浮点型之分，除此之外，Java还多了一种更小的整型：byte型，还有一种表达真假的、仅有两个值的数据类型：boolean\n&emsp;&emsp;<font color=red>基本数据类型</font>一共有4类，8种：\n&emsp;&emsp;&emsp;&emsp;1. 整型：byte、short、int、long\n&emsp;&emsp;&emsp;&emsp;2. 浮点型：float、double\n&emsp;&emsp;&emsp;&emsp;3. 字符型：char\n&emsp;&emsp;&emsp;&emsp;4. 布尔型：boolean\n#### 引用数据类型：\n&emsp;&emsp;除了基本数据类型外，Java中的各种对象称为引用数据类型\n&emsp;&emsp;<font color=red>引用数据类型</font>主要有：\n&emsp;&emsp;&emsp;&emsp;1. 数组\n&emsp;&emsp;&emsp;&emsp;2. 类：Class\n&emsp;&emsp;&emsp;&emsp;3. 接口：Interface\n&emsp;&emsp;&emsp;&emsp;4. 注解：Annotation(一种特殊的接口)\n&emsp;&emsp;我们常用的引用类型有数组(int[]整型数组，char[]字符型数组，甚至Person[]对象数组)、类(例如上面提到的String字符串类)和接口(内含抽象方法)。\n### 程序结构\n#### 分支\n&emsp;&emsp;分支结构主要有：\n&emsp;&emsp;&emsp;&emsp;1. if\n&emsp;&emsp;&emsp;&emsp;2. else\n&emsp;&emsp;&emsp;&emsp;3. else if\n&emsp;&emsp;&emsp;&emsp;4. switch...case\n&emsp;&emsp;值得注意的是：<font color=red>else总是与最近的if配对</font>\n#### 循环\n&emsp;&emsp;循环结构主要有：\n&emsp;&emsp;&emsp;&emsp;1. while循环\n&emsp;&emsp;&emsp;&emsp;2. do...while循环\n&emsp;&emsp;&emsp;&emsp;3. for循环\n&emsp;&emsp;三种循环均可以互相转换，<font color=red>do...while循环至少会执行一次</font>\n&emsp;&emsp;结束本次循环，继续下次循环<font color=red>continue关键字</font>，直接结束掉循环体<font color=red>break关键字</font>\n### 数据的输入与输出\n#### 数据输入\n&emsp;&emsp;<font color=red>利用Scanner类</font>，或利用文件操作相关的类\n&emsp;&emsp;常用写法：<code>Scanner sc = new Scanner(System.in)</code>\n#### 数据输出\n&emsp;&emsp;<font color=red>利用System类的输出流静态变量out下的多种print()方法</font>，或利用文件操作相关的类\n&emsp;&emsp;常用写法：<code>System.out.println()</code>\n\n\n## Java的面向对象\n### 简介\n&emsp;&emsp;所谓的面向对象，是相对于面向过程(C语言)而言的。\n&emsp;&emsp;例如：我们需要把一个字符串\"china\"转化为大写字母:\n&emsp;&emsp;<font color=red>面向过程</font>的思想是利用循环，分别对每一个字符的ASCII码进行处理(因为小写字母和大写字母的ASCII码存在特定的联系)\n&emsp;&emsp;而<font color=red>面向对象</font>的思想中，我们不关心具体怎么处理，而是利用一个能够处理<b>小写转为大写</b>的<font color=red>对象</font>来处理：\n&emsp;&emsp;例如String类的<code>toUpperCase()</code>方法，就能把该字符串对象转换为大写字母\n&emsp;&emsp;上面提到的String类是JDK的Java大神写好的类，类中有很多有用的<font color=red>方法</font>，除了大小写转换外，还有<code>split()</code>分割字符串、<code>substring()</code>截取字符串、<code>charAt()</code>返回某个字符的下标位置等等\n&emsp;&emsp;另外，除了JDK的大神写好的类外，我们也可以自己定义一些类，一旦定义了一个类，就能通过new关键字不断创建这个类的实例，也叫对象。可以说，<font color=green>类是对一个对象共同特征的一种抽取，它只是一个模板，是抽象的；而对象才是类的一个实例，我们的操作一般是通过实例化出来的对象来操作。</font>这一点放在第三章讲。\n### 面向对象思想\n#### 封装\n&emsp;&emsp;封装就是把具有一定共性的属性抽取出来，形成一个模板，我们称之为类(Class)，同时，我们对外尽量隐藏内部实现细节，而只提供一个公共接口(非特指interface)访问。这样可以使得程序更容易维护，也加强了安全性。\n#### 继承\n&emsp;&emsp;类(Class)与类之间是可以继承的，但要注意，Java是<font color=red>单继承</font>的，即一个类只有一个直接父类。继承对于子类来说是对父类的扩充，而父类是对子类的抽象。所以子类不但含有父类的内容，也可以新增自己的内容。\n&emsp;&emsp;例如<code>class Student extends Person</code>\n#### 多态\n&emsp;&emsp;多态是同一个行为具有多个不同表现形式或形态的能力。Java中，可以把一个<font color=red>子类赋值给一个父类。</font>\n&emsp;&emsp;例如<code>Person stu1 = new Student()</code>\n&emsp;&emsp;多态是以继承为前提的，并且多态的子类在赋值给父类时，相当于把子类当作父类使用，即此时的子类特有属性和方法被隐藏起来了。我们可以利用强制类型转换把一个多态写法中当成父类使用的子类对象重新转换为子类。\n&emsp;&emsp;例如<code>(Student)stu1</code>把Person类型的对象stu1重新转为子类Student，转为子类后的stu1对象被屏蔽掉的特有属性和方法可以使用了。\n&emsp;&emsp;但是要注意，不能把一个本来就不是子类的对象转为子类\n&emsp;&emsp;例如：\n\n```c\nPerson stu2 = new Person();\n(Student)stu2;\n//此时会引发类型转换异常\n```\n### 类中的成员\n#### 成员变量\n&emsp;&emsp;成员变量在类中仅作声明，实际上在类实例化成一个对象时才会初始化和分配空间。\n&emsp;&emsp;定义成员变量：\n```c\nclass Person{\n    int age;    //年龄\n    String name;//姓名\n}\n```\n&emsp;&emsp;成员变量可用权限修饰符修饰：public、protected、不写(default)、private\n#### 成员方法\n&emsp;&emsp;成员方法类似于C语言的函数(function)，在Java中，它叫方法(method)，用来实现某种操作。\n&emsp;&emsp;定义成员方法：\n```c\nclass Person{\n    void speak(){\n        System.out.println(\"Person类的成员方法speak()\");\n    }\n}\n```\n&emsp;&emsp;同样的，成员方法也可用权限修饰符修饰：public、protected、不写(default)、private\n#### 静态变量\n&emsp;&emsp;又叫类变量，静态变量是用static修饰的变量，此时这个变量不属于某个具体对象，而是属于类，直接利用<font color=red>类名.静态变量名</font>使用。对它的修改会影响所有用到静态变量的地方。因为它在内存中只保存了一份，任何用到它的地方都指向唯一的地址(存在于静态方法区中)。\n#### 静态方法\n&emsp;&emsp;同样的，静态方法又叫类方法，是用static修饰的方法，此时这个方法也不属于某个具体对象，而是属于类，直接利用<font color=red>类名.静态方法名</font>调用方法。\n&emsp;&emsp;<font color=green>值得注意的是，在静态方法中不能调用非静态变量(包括this关键字)，因为静态方法会<font color=red>先于</font>对象创建，此时静态方法内的非静态变量(实例变量)还没有被初始化，因为对象创建时才会初始化那些实例变量。</font>\n\n#### 静态代码块\n&emsp;&emsp;形如：\n```c\nstatic {\n    System.out.println(\"类中的静态代码块\");\n}\n```\n&emsp;&emsp;这样的代码块叫做静态代码块，它会<font color=red>在类初始化之前执行一次，且只会执行一次。</font>如果一个类中有多个静态代码块，那么会从上到下依次执行一次，且只会执行一次。\n### 构造方法和对象的初始化\n#### 构造方法\n&emsp;&emsp;构造方法是类中特殊的方法，用于初始化一个类，在创建对象(实例化一个类为对象)时调用。\n&emsp;&emsp;特点是：\n&emsp;&emsp;&emsp;&emsp;1. <font color=red>没有返回值，void也不能写。</font>\n&emsp;&emsp;&emsp;&emsp;2. <font color=red>名称与类名相同</font>\n&emsp;&emsp;&emsp;&emsp;3. <font color=red>如果不写，类中会默认隐式声明一个无参构造。一旦定义了一个构造方法，将不会隐式声明其他构造方法。</font>\n&emsp;&emsp;&emsp;&emsp;4. 可以有多种重载形式\n&emsp;&emsp;&emsp;&emsp;5. 在继承关系中，子类会默认调用父类的无参构造，形如：`super()`，并且只能写在方法的第一行。\n&emsp;&emsp;&emsp;&emsp;6. 可以利用<code>this()</code>调用其他重载的构造方法，但是不能形成递归，否则会造成栈溢出异常(StackOverflowException)。并且<code>this()</code>也只能写在方法的第一行。可见，<code>this()</code>和<code>super()</code>不可能在同一个构造方法中同时出现(因为这两句话都要求写在第一行，显然这是不可能的)。\n\n#### 对象的初始化\n&emsp;&emsp;静态代码块会在第一次使用到该类时执行，静态变量也会随之初始化。\n&emsp;&emsp;在使用new 构造方法()初始化一个对象时，会执行该类的构造方法来实例化类为对象。\n&emsp;&emsp;类中的成员变量会被初始化为<font color=red>默认值</font>。具体默认值参考：\n```c\n//默认值：\n                整型：       0\n                浮点型：     0.0\n                字符型：     '\\u0000'\n                布尔型：     false\n                引用类型：    null\n```\n&emsp;&emsp;<font color=red>new出来的对象在堆中，直到被垃圾回收。而执行方法的语句和这个方法的局部变量在栈中，当执行这个语句时会把变量压入栈，一旦方法执行完毕，方法中的数据会被立马弹出栈。</font>\n## Java常用类\n### 字符串类\n#### String\n&emsp;&emsp;最常用的字符串，底层是用final修饰的数组，所以值不可改变。\n&emsp;&emsp;可以利用\"+\"号连接字符串，但不能直接用于数值计算。值得注意的是：\n&emsp;&emsp;当利用`String str = \"abc\";`定义一个String对象时，\"abc\"这个字符串会被放入<font color=red>字符串常量池</font>，其他的字符串对象会共用这个\"abc\"字符串内容。\n&emsp;&emsp;而利用`String str = new String(\"abc\");`定义时，这个str<font color=red>指向堆中的对象</font>。\n&emsp;&emsp;我们知道，\"==\"对于基本数据类型是比较数值，而对于引用类型是比较地址值，显然，第二种方式创建的对象在堆中的地址是不同的，所以会返回false，而常量池中的对象地址相同，会返回true\n&emsp;&emsp;<font color=red>高频常用方法：</font>\n&emsp;&emsp;&emsp;&emsp;1.<code> equals()</code>：由于String类重写了Object类的equals()方法返回一个boolean值，建议在比较字符串时使用equals()方法而不是\"==\"\n&emsp;&emsp;&emsp;&emsp;2.<code> compareTo()</code>：由于String类实现了Comparable接口并重写了compareTo()方法，当两个字符串相同时，会返回0\n\n#### StringBuilder\n&emsp;&emsp;可变长度的字符串，初始长度为16加上字符串参数的长度。\n&emsp;&emsp;例如：`StringBuilder s = new StringBuilder(\"123\");`的长度为16+3=>19\n&emsp;&emsp;不能使用\"+\"号连接，可利用<code>append()</code>方法追加StringBuilder对象。\n&emsp;&emsp;可以使用<code>toString()</code>方法返回此StringBuilder对象的String类形式。\n\n#### StringBuffer\n&emsp;&emsp;相当于<font color=green>线程安全的StringBuilder</font>，由于做了同步操作，速度略慢于StringBuilder\n### 日期类\n#### Date类\n&emsp;&emsp;Java中时间的计算以1970年1月1日00:00:00为起点，计算至今的毫秒值。\n&emsp;&emsp;创建一个当前系统时间的Date对象的方法：`Date date = new Date();`\n&emsp;&emsp;Date类常用方法：\n&emsp;&emsp;&emsp;&emsp;1. <code>getTime()</code>：返回Date类对象的毫秒值\n&emsp;&emsp;&emsp;&emsp;2. <code>setTime()</code>：参数传入一个long类型的毫秒值，以设置Date对象的日期\n&emsp;&emsp;&emsp;&emsp;3. <code>getYear()</code>：返回Date对象的年份\n&emsp;&emsp;&emsp;&emsp;4. <code>getMonth()</code>：返回Date对象的月份(注意：此月份比实际月份少1，因为范围为0-11)\n&emsp;&emsp;&emsp;&emsp;5. <code>getDate()</code>：返回Date对象在月份中的天数\n&emsp;&emsp;&emsp;&emsp;6. <code>getDay()</code>：返回Date对象在一周中的星期几(注意：星期日为0)\n\n#### Calendar类\n&emsp;&emsp;Date类中的大部分方法已经由Calendar类代替。\n&emsp;&emsp;注意创建Calendar对象的方法：`Calendar cal = Calendar.getInstance();`\n&emsp;&emsp;创建的Calendar对象包含很多字段(Field)，例如一年中的第几天、一年中的第几周、年份、月份、天数等等...\n&emsp;&emsp;Calender类常用方法类似于Date类，获取字段的方法集中在get()方法中：\n&emsp;&emsp;&emsp;&emsp;1. <code>getTime()</code>：返回Calendar类对象的毫秒值\n&emsp;&emsp;&emsp;&emsp;2.<code> get()</code>：参数可以为YEAR、MONTH、DAY_OF_YEAR等等...\n&emsp;&emsp;<font color=red>同样的，注意Date类和Calendar类的月份都比实际月份少1，因为范围为0-11</font>\n\n### 集合类\n#### List\\<E>接口的集合\n&emsp;&emsp;List\\<E>接口的集合<font color=red>类似于数组</font>，它有3个特点：\n&emsp;&emsp;&emsp;&emsp;1. 有序的\n&emsp;&emsp;&emsp;&emsp;2. 有索引\n&emsp;&emsp;&emsp;&emsp;3. 允许存储重复元素\n##### ArrayList\\<E>\n&emsp;&emsp;底层是数组，查询快，增删慢\n##### LinkedList\\<E>\n&emsp;&emsp;底层是双向链表，查询慢、增删快(区别于Vector，LinkedList不同步)\n&emsp;&emsp;有特有方法：\n&emsp;&emsp;&emsp;&emsp;1. <code>addFirst(E e)</code>：插入e到开头\n&emsp;&emsp;&emsp;&emsp;2.<code> addLast(E e)</code>：插入e到结尾\n&emsp;&emsp;&emsp;&emsp;3. <code>getFirst(E e)</code>：返回第一个元素\n&emsp;&emsp;&emsp;&emsp;4. <code>getLast(E e)</code>：返回最后一个元素\n##### Vector\\<E>\n&emsp;&emsp;底层是数组，查询快，增删慢(区别于LinkedList，Vector是同步的)\n&emsp;&emsp;特有方法：<code>addElement(E e)</code>：将e添加到此集合末尾，并使大小+1\n\n#### Set\\<E>接口的集合\n&emsp;&emsp;Set\\<E>接口的集合重要特点是<font color=red>不允许重复元素</font>，特点为：\n&emsp;&emsp;&emsp;&emsp;1. 不包含重复元素\n&emsp;&emsp;&emsp;&emsp;2. 无索引(所以也就不能用普通for循环遍历，可以使用迭代器或增强for循环)\n\n##### HashSet\\<E>\n&emsp;&emsp;特点：\n&emsp;&emsp;&emsp;&emsp;1. 底层是哈希表，查询速度极快\n&emsp;&emsp;&emsp;&emsp;2. 无序的\n\n##### LinkedHashSet\\<E>\n&emsp;&emsp;&emsp;&emsp;1. 底层是哈希表，查询速度极快\n&emsp;&emsp;&emsp;&emsp;2. 有序的(多了一个链表记录顺序)\n\n#### Map<K,V>接口的集合\n&emsp;&emsp;Map集合是一个双列集合，由键K和值V组成，<font color=red>其中键K不允许重复</font>\n&emsp;&emsp;特点：\n&emsp;&emsp;&emsp;&emsp;1. K不能重复\n&emsp;&emsp;&emsp;&emsp;2. K和V的类型任意\n&emsp;&emsp;&emsp;&emsp;3. 每一个K只对应一个V\n&emsp;&emsp;常用方法：\n&emsp;&emsp;&emsp;&emsp;1. <code>put(K k,V v)</code>：把一个元素放入集合，如果K已经存在则替换原来的V为新V\n&emsp;&emsp;&emsp;&emsp;2. <code>get(Object k)</code>：取出K对应的V，如果不存在则返回null\n&emsp;&emsp;&emsp;&emsp;3. <code>remove(Object k)</code>：删除K指定的键值对\n&emsp;&emsp;&emsp;&emsp;4. <code>clear()</code>：清空这个Map集合\n## Swing图形化\n### Java的图形化\n&emsp;&emsp;我们主要学习Swing和AWT，但是AWT是早期SUN公司提供的GUI开发工具包，它与Swing最显著的特点就是AWT是利用了操作系统提供的图形库，其缺点很明显：显然每个操作系统的图形库是不同的，这导致AWT的跨平台GUI软件界面不统一。\n&emsp;&emsp;而Swing是Java基础类的一部分，它提供了比AWT更好的显示元素，而且是用纯Java写的，但显然，运行速度肯定是直接调用操作系统图形库的AWT更快，所以AWT叫做重量级组件，而Swing叫做轻量级组件(不用怀疑，没有写反)。\n&emsp;&emsp;我们可以简单的判断一个组件是否是Swing组件：<font color=red>Swing组件以'J'开头</font>，例如JLabel、JButton。\n### Swing组件和容器\n&emsp;&emsp;组件不能单独启动，要放在容器中。\n&emsp;&emsp;容器(Container)也是组件(Component)的一种。\n&emsp;&emsp;我们最常用的<code>JFrame</code>容器就是<code>Container</code>的一个子类，显然，也是<code>Component</code>的一个子类，见下方继承图。\n&emsp;&emsp;其他诸如<code>JLabel</code>就是<code>JComponent</code>的一个子类，这里的<code>JComponent</code>其实也是<code>Container</code>的一个子类，当然，也就是<code>Component</code>的一个子类了(子类什么的看下方继承图!)。区别就在于'J'开头的组件存在于<font color=red>javax.swing</font>包下，而普通组件在<font color=red>java.awt</font>包下。\n&emsp;&emsp;来看看我们最常用的独立容器：JFrame的继承图：\n![JFrameExtends](JFrameExtends.png)\n&emsp;&emsp;显然，JFrame继承自Frame，同样的，也继承自更高层的父类Window、Container以至于Component，别忘了，Java中最最高级的根父类是Object，那么它也间接继承自Object类，并实现了一些接口罢了。\n&emsp;&emsp;看看容器有哪些：\n<img src=\"./Container.png\" width = \"500\" height = \"260\" alt=\"容器\" align=center />\n\n### 常用Swing组件\n#### JFrame\n&emsp;&emsp;用于创建一个窗口\n&emsp;&emsp;首先导入包：\n&emsp;&emsp;&emsp;&emsp;1. <code>import javax.swing.*</code>;\n&emsp;&emsp;&emsp;&emsp;2. <code>import java.awt.*</code>;\n&emsp;&emsp;构造方法：\n&emsp;&emsp;&emsp;&emsp;<code>Frame fm = new Frame()</code>创建一个不可见的窗口\n&emsp;&emsp;&emsp;&emsp;<code>Frame fm = new Frame(String title)</code>创建一个带标题的不可见的窗口\n&emsp;&emsp;发现了吗？创建的窗口都<font color=red>不可见</font>，因为创建的窗口默认高度宽度都为0，而且可见性为false。那么想要<font color=red>显示窗口</font>，就需要两步：\n&emsp;&emsp;&emsp;&emsp;1. <code>setSize(int width,int height)</code> ：设置一个宽度和高度\n&emsp;&emsp;&emsp;&emsp;2. <code>setVisible(boolean b) </code>：设置可见性为true\n&emsp;&emsp;值得注意的是JFrame的<font color=red>默认布局</font>为BorderLayout，这可以使你轻松创建一个具有上、下、左、右、中，一共5个区域的布局，但在BorderLayout中，方向以东南西北中表示。\n#### JPanel\n&emsp;&emsp;是一个中间容器，<font color=red>必须放置在其他容器中</font>，采用了双缓冲，减少窗口闪烁。\n&emsp;&emsp;经常用于把其他组件加入到JPanel中，再把JPanel一次性加入到其他容器中。\n#### JLabel\n&emsp;&emsp;用于显示文本或图片。默认文本靠左对齐，上下居中对齐。\n&emsp;&emsp;常用方法：<code>setText(String text)</code>设置这个JLabel的文本\n#### JTextArea\n&emsp;&emsp;一个用来显示文本的多行区域。\n&emsp;&emsp;使用技巧：如果想要这个多行文本区域具有<font color=red>滚动条</font>，可以把这个JTextArea加入到JScrollPane组件中。\n#### JButton\n&emsp;&emsp;一个按钮，可以实现ActionListener动作监听器来响应<font color=red>点击事件</font>。这个点击事件的处理在<code>actionPerformed()</code>方法中。\n&emsp;&emsp;你需要把这个按钮调用<code>addActionListener(ActionLisenter l)</code>并传入一个动作监听器，当你在本类实现了ActionLisenter接口中的方法，那么可以直接传入<code>this</code>\n#### JComboBox\n&emsp;&emsp;一个下拉列表，可以设置单选、多选等模式。\n&emsp;&emsp;常用方法：\n&emsp;&emsp;&emsp;&emsp;1. <code>getSelectedIndex()</code>：获取当前选择项的索引\n&emsp;&emsp;&emsp;&emsp;2. <code>getSelectedItem()</code>：获取当前选择项(Object类型)\n&emsp;&emsp;&emsp;&emsp;3. <code>addItem(E item)</code>：把一个泛型元素加入到下拉列表\n&emsp;&emsp;&emsp;&emsp;4. <code>removeItemAt(int index)</code>：删除指定索引的元素\n&emsp;&emsp;&emsp;&emsp;3. <code>removeAllItems()</code>：删除列表所有的元素\n### 常用布局\n&emsp;&emsp;设置布局调用<code>setLayout()</code>方法传入一个实现了LayoutManager接口的布局对象，例如FlowLayout、GridLayout等...\n&emsp;&emsp;就像这样：<code>this.setLayout(new FlowLayout);</code>\n&emsp;&emsp;或者针对某个面板设置它的布局：\n```c\n    JPanel pn = new JPanel();\t//创建JPanel对象\n    pn.setLayout(new GridLayout); //设置JPanel对象的布局\n```\n&emsp;&emsp;Swing相比AWT新增了BoxLayout布局，然而我们<font color=blue>主要学习以下三种布局：</font>\n#### FlowLayout\n&emsp;&emsp;<font color=red>流式布局</font>，元素按照从左到右依次排列，元素<font color=red>大小不变，位置会变</font>，默认水平垂直间距均为5\n#### GridLayout\n&emsp;&emsp;<font color=red>网格布局</font>，构造方法中指定一个行数和列数，元素<font color=red>大小会变，相对位置不变</font>，默认为1行0列，水平垂直间距均为0；\n#### BorderLayout\n&emsp;&emsp;<font color=red>边框布局</font>，构造方法中指定水平间距和垂直间距，<font color=red>CENTER部分大小会变，四周大小不变</font>，默认水平垂直间距均为0；\n![Layout](Layout.png)\n&emsp;&emsp;<font color=blue>在上面的GUI软件中，很明显主体采用<font color=red>BorderLayout</font>，这种边框布局在放入组件时需要指定放入到东南西北中的哪个位置，否则默认为CENTER，中间的留言内容区域为<font color=red>CENTER</font>区域，而下方的表情选择、输入框都在<font color=red>SOUTH</font>区域，右侧的6个按钮在<font color=red>EAST</font>区域，还有\"留言板\"的小标题在<font color=red>NORTH</font>区域，<font color=red>WEST</font>区域没放东西。\n&emsp;&emsp;而SOUTH区域明显有JLabel标签、JComboBox下拉列表、以及JTextField单行输入框和一个JButton提交按钮，这些组件都是从左到右依次排列的，那么就很显然是FlowLayout流式布局了。\n&emsp;&emsp;右侧EAST区域的6个按钮排列整齐，可以利用一个8行，但只有1列的GridLayout网格布局放置这些按钮。\n&emsp;&emsp;顶部NORTH区域就不用说了，只有一个组件，随便什么布局都可以，但也建议使用FlowLayout流式布局。\n</font>\n### 保姆级案例\n#### 创建一个窗口\n&emsp;&emsp;就像在1.5.2中说的那样，<font color=red>创建一个窗口</font>要导入包、设定构造方法、设置大小和可见性。具体来说就是首先继承JFrame类，然后定义构造方法...\n![JFrameBasic](JFrameBasic.png)\n```c\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class MyFrame extends JFrame {\n    public MyFrame(String title) throws HeadlessException {\n        super(title);\n        setSize(400,300);\n        setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new MyFrame(\"这是标题\");\n    }\n}\n```\n#### 往窗体里添加一些东西\n![JFrameBasic2](JFrameBasic2.png)\n&emsp;&emsp;我们添加了一个文本标签JLabel到JFrame中一共<font color=red>花了4步</font>，而且由于JFrame默认是BorderLayout布局，所以在第4步调用<code>add()</code>方法时，可以指定添加到东南西北中哪个方位，这里我们就加入到了南方(也就是下方)。\n&emsp;&emsp;显然，我们如果想再加入一个文本在最上方(也就是NORTH北方)，就像这样：\n![JFrameBasic3](JFrameBasic3.png)\n&emsp;&emsp;发现什么区别了吗，我们这次<font color=red>只花了2步</font>，相对于上次并没有new什么JPanel，而是直接把new出来的JLabel文本标签直接add到NORTH北方区域，文本靠左对齐了，就像在1.5.3.3中讲的那样(你不会才知道右侧有目录吧？！)，其实就是这两步：\n![JFrameBasic4](JFrameBasic4.png)\n&emsp;&emsp;但是上面的JLabel文本标签<font color=red>没有居中对齐</font>，逼死强迫症？只需要调用<code>setHorizontalAlignment()</code>方法传入一个int数值就可以，居中CENTER其实相当于写0：\n![JFrameBasic5](JFrameBasic5.png)\n&emsp;&emsp;现在假设我们需要一个<font color=red>文本区域</font>，可以供我们输入很多文字，而且这个文本区域最好在窗口中间...那么很明显定义一个JTextArea，然后放入JFrame的CENTER区域就行了：\n![JFrameBasic6](JFrameBasic6.png)\n&emsp;&emsp;<font color=red>结合上面几个案例，不难看出，一般情况下添加一个组件到JFrame窗口，两步就够了：</font>\n&emsp;&emsp;&emsp;&emsp;1. new一个你想要的组件，比如JLabel、JTextArea等等\n&emsp;&emsp;&emsp;&emsp;2. 调用`add()`方法并指定添加到东南西北中哪个方位\n#### 关闭按钮\n&emsp;&emsp;然而实际上自己运行一下会发现，我们做的窗口点击关闭按钮后，窗口确实消失了，但是你的IDE(比如eclipse、IDEA)并没有显示这个进程退出了，也就是说你的窗口程序还在运行。\n&emsp;&emsp;所以想让窗口的关闭按钮正确结束掉你的窗口程序，常用的有以下<font color=red>两种方法：</font>\n&emsp;&emsp;&emsp;&emsp;1. 调用<code>addWindowListener()</code>传入一个WindowAdapter对象并重写<code>windowClosing()</code>方法，方法内执行<code>System.exit(0);</code>\n![JFrameBasic7](JFrameBasic7.png)\n&emsp;&emsp;&emsp;&emsp;2. 调用<code>setDefaultCloseOperation()</code>并传入一个int值，例如3相当于<code>EXIT_ON_CLOSE</code>\n![JFrameBasic8](JFrameBasic8.png)\n&emsp;&emsp;<font color=red>反正我是喜欢第二种关闭方法，一句话搞定。</font>\n#### JPanel(面板)的作用\n&emsp;&emsp;通过以上案例，你已经能写出一个可以随心所欲设置放置到哪个位置的窗口程序，并且关闭按钮也可以正常结束掉程序。但是有没有注意到，我们第一次添加那个JLabel文本标签的时候，它是被放入到一个JPanel面板中的，而且它竟然居中了，这是由于JPanel默认为FlowLayout流式布局，会从左到右依次排列组件并且居中。\n&emsp;&emsp;也就是说，<font color=red>我们可以把一些乱七八糟的组件都加入到一个JPanel面板中，最后一次性把JPanel加入到JFrame的某个位置就行了。</font>\n![JFrameBasic9](JFrameBasic9.png)\n&emsp;&emsp;运用同样的方法，你可以把一些乱七八糟的组件都加到另一个面板中，然后一次性把面板加入到其他位置，比如SOUTH南方放置上面案例中的那些组件，而EAST东方可以放置一些按钮，这些按钮都放在一个面板中，NORTH北方也可以放一个面板，面板里面可以放置一下乱七八糟的组件...","tags":["Java"],"categories":["JavaSE知识总览"]},{"title":"Java-swing图形化——小小留言板","url":"/2021/05/01/Java-Swing/","content":"\n<big><b><center><font color='red'>=====taoyyz小陶©版权所有=====</font></center></b></big>\n\n<font size=6><center>实验四 图形界面及应用系统的设计</center></font>\n\n# 要求：\n\n&emsp;&emsp;制作如图一个留言板的界面，并按要求加入所需控件，并能按要求进行窗口控件的布局。并按要求为按钮、文本框、窗口添加事件，使之实现提交显示留言，清屏，留言至顶和至尾。要求文本框能自动产生滚动条，界面美观。\n\n<font size=2> \n<b>注意：</b></br>\n1、通过两个文本文件存储表情和留言内容。</br>\n&emsp;&emsp;1）Expression.dat：用于存储表情，如：微笑、大哭、流泪等；每个表情占一行。</br>\n&emsp;&emsp;2）Msg.dat：用于存储留言信息，留言信息格式为：\n `[2019-10-04 12:35] 你微笑地说：今天下午去图书馆吗？`\n 其中：时间是提交留言的时间，每条留言一行。</br>\n2、窗口启动的时候（或点击“查看”按钮时），从 Msg.dat 文件中读出所有留言\n记录，显示在文本框中；从 Expression.dat 文件中读出所有表情记录，显示在\n表情下拉列表中。将 Msg.dat 中所有留言记录，倒序显示在文本域中。 </br>\n3、点击提交按钮，将表单内容存入文件，同时刷新文本框的留言内容。</br>\n4、“清屏”代表清除留言框内容，“至顶”和“至尾”功能是当留言内容过多时，\n将滚动条滚动到最上面或最下面，实现过程为移动文本区域里面的光标，使\n其指向第一个位置和最后一个位置。（设置光标位置函数为：setCaretPosition（int 位置））</br>\n5、（选作）增加“表情维护”按钮，在新窗口修改表情文件的内容</br>\n6、（选作）增加“删除留言”按钮，在新窗口通过选择数字或全部删除相关的留言内容</br>\n7、时间安排：前 3 学时，做界面和基本的显示效果操作事件，后 3 学时将文件操作引入相关的事件中。\n</font>\n\n# 思路：\n\n定义3个类，分别为留言板主界面类MessageBoard，表情维护类ExpressionManager，删除留言类DeleteMsg</br><b>重要方法：</b></br>&emsp;&emsp;1.在多个方法之间产生交互的组件最好定义为全局成员变量</br>&emsp;&emsp;2.显示窗口的2个必不可少的步骤：setSize()和setVisible(true)</br>&emsp;&emsp;3.根据需要选择合适的Layout，最外层窗口选择BorderLayout最合适</br>&emsp;&emsp;4.可以利用方法的可变参数列表来一次性初始化多个组件，很方便！</br>&emsp;&emsp;5.新增、删除、修改留言之后要再次调用相应的load方法重新载入达到刷新效果</br>&emsp;&emsp;6.其他类需要调用主类的方法时，可以把主类方法设置为静态static的</br>&emsp;&emsp;7.JList类配合Collection集合类进行增删改</br>&emsp;&emsp;8.把集合内容作为参数作为JList的数据，调用setListData()方法</br>\n# 代码：\n\n```c MessageBoard类(含main方法)：\npackage com.experiment.exp4;\n/*\n    小小留言板类，此类实现了一个简易的留言板，包括留言/展示、选择表情、清屏、滚动到顶部/底部、删除留言等功能\n    继承于JFrame类，为按钮增加了ActionListener监听器，利用ComponentListener监听窗口大小改变以实现标题居中\n        1.整体采用BorderLayout布局：\n            1.1 CENTER区域显示留言内容，并可以随时更新\n            1.2 EAST区域放置常用功能，例如清屏、至顶/尾、查看、表情维护、删除留言功能\n            1.3 SOUTH区域可以输入留言，并选择表情\n        2.在构造方法中指定窗口的标题、设置窗口大小、并初始化组件(加入窗口组件监听、限制窗口大小、设置窗口居中屏幕以及标题居中)\n        3.标题居中：通过FontMetrics类的stringWidth()方法得到当前字体所占用的宽度，来计算出需要在标题前补多少个空格\n        4.CENTER区域的JTextArea设置自动换行，并放入JScrollPane中，设置垂直滚动条\n        5.EAST区域的6个按钮放置在8行1列的GridLayout布局中，方便排列\n        6.SOUTH区域采用FlowLayout布局，并利用setPreferredSize设置面板大小\n        7.在actionPerformed()方法中分别对各个按钮的事件进行动作响应：\n            7.1 留言按钮除了会把输入框的内容追加到JTextArea中，还会调用saveMsg()方法保存到本地文本文件中\n            7.2 清屏按钮仅对JTextArea区域清空，不会影响本地文本文件中的内容\n            7.3 查看功能会调用loadMsg()再次载入本地文本文件中的留言内容，loadMsg()在WinInit()过程中会被初次调用\n            7.4 至顶：即调用setCaretPosition()并传入参数为0，把光标移至文本开头\n            7.5 至尾：即调用setCaretPosition()并传入参数为JTextArea实例的字符串长度，相当于把光标移至末尾\n            7.6 表情维护：调用manageExp()产生ExpressionManager对象，此对象会生成一个JFrame窗口，用于管理表情\n            7.7 删除留言：调用deleteMsg()产生DeleteMsg对象，此对象会生成一个JFrame窗口，用于删除留言\n        8.有个坑：双显示器场景下，窗口在副屏选中了JComboBox的某个内容，点击按钮(表情维护、删除留言)产生新JFrame对象时会导致那个按钮所处的面板下方花屏，猜测是面板没有刷新导致。仅在双显示器窗口位于副屏下重现。解决方法：调用repaint()方法重绘面板组件。\n */\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.ComponentListener;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/5/1 11:07\n * @Version 1.0\n */\npublic class MessageBoard extends JFrame implements ComponentListener, ActionListener {\n    private static JTextArea textArea;\n    private static JComboBox<String> expressions;\n    private JTextField inputText;\n    private JButton submit;\n    private JButton clear;\n    private JButton toTop;\n    private JButton toTail;\n    private JButton viewAll;\n    private JButton expressionManager;\n    private JButton delete;\n    private final String title;\n    public static final String filePath = \"C:\\\\Users\\\\SBTTG\\\\Desktop\\\\\" +\n            \"IDEA\\\\Demo\\\\src\\\\main\\\\java\\\\com\\\\experiment\\\\exp4\";\n\n    public MessageBoard(String title) throws HeadlessException {\n        super(title);\n        this.title = title;\n        setSize(640, 480);\n        WinInit(title);\n    }\n\n    public static void main(String[] args) {\n        MessageBoard mb = new MessageBoard(\"小小留言板\");\n    }\n\n    private void WinInit(String title) {\n        setLayout(new BorderLayout()); //设置整体JFrame布局为BorderLayout\n        setTitleCenter(title); //设置标题居中\n        addComponentListener(this); //加入组件监听器，主要是为了检测窗口大小变动\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //设置关闭按钮功能\n        setLocationRelativeTo(null); //设置窗口位置默认为屏幕中间\n        setMinimumSize(new Dimension(560, 420)); //设置窗口最小尺寸\n        //实例化组件\n        initTopPanel();\n        initRightPanel();\n        initBelowPanel();\n        initCenterPanel();\n        //下面的语句利用可变参数列表一次性设置按钮样式和监听器，我也太J8机智了\n        setButtonStyleAndListener(clear, toTop, toTail, viewAll, submit, expressionManager, delete);\n        setVisible(true); //设置可见性-->必须放在最后面，否则此语句后面的语句不生效，需要产生事件刷新屏幕才会生效\n    }\n\n    private void initCenterPanel() {\n        textArea = new JTextArea();\n        textArea.setText(\"留言内容：\\n\");\n        loadMsg();\n        textArea.setEditable(false);\n        textArea.setWrapStyleWord(true);\n        textArea.setLineWrap(true);\n        textArea.setFont(new Font(\"微软雅黑\", Font.PLAIN, 14));\n//        textArea.append(\"呵呵哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\\n\");\n        JScrollPane centerScrollPane = new JScrollPane(textArea, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n        add(centerScrollPane, BorderLayout.CENTER);\n    }\n\n    private void initBelowPanel() {\n        JPanel below = new JPanel();\n        below.setLayout(new FlowLayout());\n        below.setPreferredSize(new Dimension(540, 40)); //BorderLayout下只能用这种方式修改面板大小\n        below.add(new JLabel(\"你\"));\n        expressions = new JComboBox<>();\n//        expressions.addItem(\"微笑\");\n//        expressions.addItem(\"开心\");\n        loadExp();\n        below.add(expressions);\n        below.add(new JLabel(\"地说：\"));\n        submit = new JButton(\"提交\");\n        inputText = new JTextField(20);\n        below.add(inputText);\n        below.add(submit);\n        add(below, BorderLayout.SOUTH);\n    }\n\n    private void initTopPanel() {\n        JPanel top = new JPanel();\n        JLabel title = new JLabel(\"留言板\");\n        title.setVerticalAlignment(SwingConstants.CENTER);\n        top.add(title);\n        add(top, BorderLayout.NORTH);\n    }\n\n    private void initRightPanel() {\n        JPanel right = new JPanel();\n        right.setLayout(new GridLayout(8, 1, 0, 25));\n        clear = new JButton(\"清屏\");\n        toTop = new JButton(\"至顶\");\n        toTail = new JButton(\"至尾\");\n        viewAll = new JButton(\"查看\");\n        expressionManager = new JButton(\"表情维护\");\n        delete = new JButton(\"删除留言\");\n        right.add(clear);\n        right.add(toTop);\n        right.add(toTail);\n        right.add(viewAll);\n        right.add(expressionManager);\n        right.add(delete);\n        add(right, BorderLayout.EAST);\n    }\n\n    private void setButtonStyleAndListener(JButton... buttons) {\n        for (JButton btn : buttons) {\n            btn.addActionListener(this); //加入按钮动作监听器\n            btn.setFocusPainted(false); //取消掉按钮点击后的虚线框\n            btn.setCursor(new Cursor(Cursor.HAND_CURSOR)); //设置光标悬停样式为小手\n        }\n    }\n\n    private void setTitleCenter(String title) {\n        setFont(new Font(\"System\", Font.PLAIN, 14));\n        FontMetrics fm = this.getFontMetrics(this.getFont());\n        String spaces = String.format(\"%\" + ((this.getWidth() - title.length()) / 2\n                / fm.stringWidth(\" \") - fm.stringWidth(title) / 4) + \"s\", \"\");\n        setTitle(spaces + title);\n    }\n\n    public static void loadMsg() {\n        textArea.setText(\"留言内容：\");\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(filePath + \"\\\\Msg.dat\"));\n            String msg;\n            while ((msg = reader.readLine()) != null) {\n                textArea.insert(\"\\n\" + msg, \"留言内容：\".length());\n            }\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void loadExp() {\n        expressions.removeAllItems();\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(filePath + \"\\\\Expression.dat\"));\n            String exp;\n            while ((exp = reader.readLine()) != null) {\n                expressions.addItem(exp);\n            }\n            reader.close();\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    private void saveMsg(String msg) {\n        try {\n            //注意这里的FileWriter构造方法应该调用带是否追加的，即第二个参数设定为true，否则默认覆盖\n            FileWriter fw = new FileWriter(MessageBoard.filePath + \"\\\\Msg.dat\", true);\n            fw.append(msg).append(\"\\n\");\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (e.getSource() == submit) {\n            if (!(inputText.getText().equals(\"\"))) {\n                SimpleDateFormat sf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm\");\n                String msg = \"[\" + sf.format(new Date()) + \"]\" + \" 你\"\n                        + expressions.getSelectedItem() + \"地说：\" + inputText.getText();\n                textArea.insert(\"\\n\" + msg, \"留言内容：\".length());\n                saveMsg(msg);\n                inputText.setText(null);\n            }\n        } else if (e.getSource() == clear) {\n            textArea.setText(\"留言内容：\\n\");\n        } else if (e.getSource() == toTop) {\n            textArea.setCaretPosition(0);\n        } else if (e.getSource() == toTail) {\n            System.out.println(\"文本长度：\" + textArea.getText().length());\n            textArea.setCaretPosition(textArea.getText().length());\n        } else if (e.getSource() == viewAll) {\n            System.out.println(\"查看\");\n            loadMsg();\n        } else if (e.getSource() == expressionManager) {\n            manageExp();\n            right.repaint(); //我擦？竟然有残影，利用repaint()刷新面板解决\n        } else if (e.getSource() == delete) {\n            deleteMsg();\n            right.repaint(); //同理\n        }\n    }\n\n    @Override\n    public void componentResized(ComponentEvent e) {\n        setTitleCenter(title);\n    }\n\n    @Override\n    public void componentMoved(ComponentEvent e) {\n\n    }\n\n    @Override\n    public void componentShown(ComponentEvent e) {\n\n    }\n\n    @Override\n    public void componentHidden(ComponentEvent e) {\n\n    }\n\n    private void manageExp() {\n        ExpressionManager em = new ExpressionManager(\"表情\");\n        System.gc();\n    }\n\n    private void deleteMsg() {\n        DeleteMsg dm = new DeleteMsg(\"删除\");\n        System.gc();\n    }\n}\n\n```\n\n```c ExpressionManager类：\npackage com.experiment.exp4;\n/*\n    表情维护 继承于JFrame：\n        1.采用BorderLayout布局\n            1.1 CENTER部分放置一个可编辑的JTextArea(加入滚动条)，用于操作修改表情文本\n            1.2 SOUTH部分放置2个按钮，分别用于确定和取消\n        2.首先在构造方法中设置窗口大小，调用初始化方法来初始化组件，设置可见性为可见\n        3.对于初始化方法，可以利用可变参数列表来适应参数个数，达到一次性设置按钮样式以及监听器\n        4.把CENTER区域的JTextArea放入JScrollPane中，设置产生垂直滚动条\n        5.在按钮动作监听事件中分别处理2个按钮的行为：\n            4.1 确认按钮：在按下此按钮之前，可以任意修改JTextArea区域的表情文本\n                        当按下此按钮，调用saveExp()方法保存表情\n                        要注意保存完毕后刷新面板，即调用loadExp()方法重新载入表情\n            4.2 取消按钮：直接调用dispose()方法关闭此Window，不影响其他JFrame\n */\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/5/1 16:01\n * @Version 1.0\n */\npublic class ExpressionManager extends JFrame implements ActionListener {\n    static JButton confirm;\n    static JButton cancel;\n    JTextArea textArea;\n    JPanel btnPanel;\n\n    public ExpressionManager(String title) throws HeadlessException {\n        super(title);\n        setSize(200, 250);\n        WinInit();\n        setVisible(true);\n    }\n\n    private void WinInit() {\n        setLayout(new BorderLayout());\n        setLocationRelativeTo(null);\n        setMinimumSize(new Dimension(230, 300));\n        initContent();\n        initBtnPanel();\n        setButtonAction(confirm, cancel);\n        setDefaultCloseOperation(DISPOSE_ON_CLOSE);\n    }\n\n    private void setButtonAction(JButton... buttons) {\n        for (JButton button : buttons) {\n            button.addActionListener(this);\n        }\n    }\n\n    private void initContent() {\n        textArea = new JTextArea();\n        textArea.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16));\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(MessageBoard.filePath\n                    + \"\\\\Expression.dat\"));\n            String exp;\n            while ((exp = reader.readLine()) != null) {\n                textArea.append(exp + \"\\n\");\n            }\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n        JScrollPane centerScrollPane = new JScrollPane(textArea, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n        add(centerScrollPane, BorderLayout.CENTER);\n    }\n\n    private void initBtnPanel() {\n        btnPanel = new JPanel();\n        btnPanel.setPreferredSize(new Dimension(180, 40));\n        confirm = new JButton(\"确认\");\n        cancel = new JButton(\"取消\");\n        btnPanel.add(confirm);\n        btnPanel.add(cancel);\n        add(btnPanel, BorderLayout.SOUTH);\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (e.getSource() == confirm) {\n            System.out.println(\"确定\");\n            saveExp();\n            MessageBoard.loadExp(); //记得刷新主面板的表情列表\n            dispose();\n        } else if (e.getSource() == cancel) {\n            System.out.println(\"取消\");\n            dispose();\n        }\n    }\n\n    private void saveExp() {\n        try {\n            FileWriter fw = new FileWriter(MessageBoard.filePath + \"\\\\Expression.dat\");\n            fw.write(\"\");\n            fw.write(textArea.getText());\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n\n```\n```c DeleteMsg类：\npackage com.experiment.exp4;\n/*\n    删除留言 继承于JFrame：\n        1.采用BorderLayout布局：\n            1.1 CENTER部分放置一个JList，用于显示所有留言\n            1.2 SOUTH部分放置3个JButton，分别用于删除单项、删除全部、取消\n        2.首先在构造方法中设置窗口大小，调用初始化方法来初始化组件，设置可见性为可见\n        3.对于初始化方法，可以利用可变参数列表来适应参数个数，达到一次性设置按钮样式以及监听器\n        4.在按钮动作监听事件中分别处理3个按钮的行为：\n            4.1 取消按钮直接调用dispose()释放此Window，不影响其他JFrame，相当于关闭此窗口\n            4.2 删除按钮：如果选中了一个JList中的内容，那么调用delete()方法移除它\n                4.2.1 发现一个问题，直接调用JList实例的remove()方法并不会正确移除\n                      但可以通过其他手段处理列表元素(例如通过集合中的remove和add等方法)\n                      然后通过处理过后的集合作为参数，调用setListData(E[] listData)\n                也就是说，操作JList数据实际上是通过另一个Collection集合来进行增删改\n                把修改完成之后的Collection集合内容作为参数重新产生JList的数据\n            4.3 删除全部：同样的，也是通过Collection集合的clear()方法清空集合\n                        然后把这个空集合作为参数，调用setListData()达到清空JList效果\n */\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/5/1 17:16\n * @Version 1.0\n */\npublic class DeleteMsg extends JFrame implements ActionListener {\n    JButton delete;\n    JButton deleteAll;\n    JButton cancel;\n    JPanel btnPanel;\n    JList<String> msgList;\n    ArrayList<String> messages;\n\n    public DeleteMsg(String title) throws HeadlessException {\n        super(title);\n        setSize(400, 300);\n        WinInit();\n        setVisible(true);\n    }\n\n    private void WinInit() {\n        setLocationRelativeTo(null);\n        setLayout(new BorderLayout());\n        msgList = new JList<>();\n        msgList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        loadList();\n        add(msgList, BorderLayout.CENTER);\n        btnPanel = new JPanel();\n        delete = new JButton(\"删除\");\n        deleteAll = new JButton(\"删除全部\");\n        cancel = new JButton(\"取消\");\n        btnPanel.add(delete);\n        btnPanel.add(deleteAll);\n        btnPanel.add(cancel);\n        setButtonStyleAndListener(delete, deleteAll, cancel);\n        add(btnPanel, BorderLayout.SOUTH);\n        setMinimumSize(new Dimension(400, 300));\n        setDefaultCloseOperation(DISPOSE_ON_CLOSE);\n    }\n\n    private void setButtonStyleAndListener(JButton... buttons) {\n        for (JButton btn : buttons) {\n            btn.addActionListener(this); //加入按钮动作监听器\n            btn.setFocusPainted(false); //取消掉按钮点击后的虚线框\n            btn.setCursor(new Cursor(Cursor.HAND_CURSOR)); //设置光标悬停样式为小手\n        }\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (e.getSource() == cancel) {\n            System.out.println(\"取消\");\n            dispose();\n        } else if (e.getSource() == delete) {\n            System.out.println(\"删除\");\n            delete();\n            loadList();\n        } else if (e.getSource() == deleteAll) {\n            System.out.println(\"删除全部\");\n            deleteAll();\n            loadList();\n        }\n    }\n\n    private void deleteAll() {\n        messages.clear();\n        updateMsgList();\n    }\n\n    private void delete() {\n        if (msgList.getSelectedIndex() != -1) {\n            messages.remove(msgList.getSelectedIndex());\n            updateMsgList();\n        }\n    }\n\n    private void updateMsgList() {\n        try {\n            FileWriter fw = new FileWriter(MessageBoard.filePath + \"\\\\Msg.dat\");\n            fw.write(\"\");\n            for (String message : messages) {\n                fw.write(message + \"\\n\");\n            }\n            fw.flush();\n            fw.close();\n            MessageBoard.loadMsg();\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    private void loadList() {\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(MessageBoard.filePath + \"\\\\Msg.dat\"));\n            messages = new ArrayList<>();\n            String msg;\n            while ((msg = reader.readLine()) != null) {\n                messages.add(msg);\n            }\n            String[] msgs = new String[messages.size()];\n            for (int i = 0; i < messages.size(); i++) {\n                msgs[i] = messages.get(i);\n            }\n            msgList.setListData(msgs);\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n\n```\n\n# 运行截图：\n\n![main](main.png)![expression](expression.png)![delete](delete.png)![compare](compare.png)\n\n\n# 心得：\n\n<font size=3>\n&emsp;&emsp;五一第一天，室友凌晨1点就在学习我淦！疯狂卷是吧？睡到中午11点赶紧开始今天一天的学习，总的来说这次实验掌握了swing的很多方法，也踩了好几个坑，例如<code>setVisible()</code>位置不对，导致后初始化的组件显示不出来，这时候拖动窗口缩放才会显示，困扰了半天，原来只需要把<code>setVisible()</code>放在组件初始化语句后面就可以正常显示了。<br>\n&emsp;&emsp;在JList的使用上也有很多坑，JList自带的<code>remove()</code>方法和<code>removeAll()</code>方法居然不能正常移除列表中的元素，而且还会报下标越界异常，真的🐔8坑。好在解决方法是：定义一个Collection集合作为JList的操作辅助，因为Collection集合刚好也带有<code>remove()、clear()、add()</code>这些方法，在Collection集合中操作内容之后，把每一个元素全部存入一个对象数组中，作为参数传入JList的<code>setListData()</code>方法重新设置JList内容就可以变相操作JList。（妈的为什么不能直接用JList的<code>remove()</code>等等方法啊，但是<code>getSelectedIndex()</code>又可以正常获取到点击的下标，害！）<br>\n&emsp;&emsp;swing现在用的好像并不多，毕竟Java运行在JVM上，相比于native还是多了一层。虽然好处是跨平台。<br>\n&emsp;&emsp;JavaWeb才是永远滴神，有浏览器就能用，为什么不学JavaWeb呢？</br>&emsp;&emsp;耗时一天完成了这个swing小程序，终于脱离Console枯燥的文字了，图形化编程还是挺有成就感的🤩！</font>","tags":["Java","Swing"],"categories":["Java实训题"]},{"title":"C++第一次实验","url":"/2021/04/26/C-FirstExp/","content":"\n<big><b><center><font color='red'>=====taoyyz小陶©版权所有=====</font></center></b></big>\n<font size=6><center>实验一 C++运行环境及基础语法</center></font>\n\n# 要求：\n&emsp;&emsp;1.熟悉C++的开发运行环境\n&emsp;&emsp;2.掌握C++的基本语法\n&emsp;&emsp;3.熟悉结构化程序设计\n\n# 思路：\n&emsp;&emsp;`全是有手就行的题`\n\n# 代码：\n## 最简单的C++程序运行调试\n```c\n#include <iostream>\n\nvoid main()\n{\n\tstd::cout<<\"my first cpp program\"<<std::endl;\n}\n```\n## 结构化程序设计基础\n用long long存放结果：\n```c\n#include<iostream>\nusing namespace std;\nint main1(){\n\tlong long n,fact=1;\n\tcout<<\"input a num:\";   //这条语句有错，应怎么改？\n\tcin>>n;\n\tint i=1;\n\tfor(;i<=n;i++)\n\t{\n\t\tfact=fact*i;\n\t}\n\tcout<<n<<\"!=\"<<fact<<endl;\n\tcout<<i<<endl;\n\treturn 0;\n}\n```\n用数组存放结果：\n```c\n#include <iostream>\nusing namespace std; \nint main()\n{\n    int n;\n    int arr[100];\n    int num = 1; \n    int temp;\n    int i, j, c;\n    cout << \"输入一个n：\";\n    cin >> n;\n    arr[0] = 1;\n    for (i = 2; i <= n; i++)\n    {\n        for (j = 1, c = 0; j <= num; j++)\n        {\n            temp = arr[j - 1] * i + c;\n            arr[j - 1] = temp % 10;\n            c = temp / 10;\n        }\n        while (c)\n        {\n            arr[++num - 1] = c % 10;\n            c = c / 10;\n        }\n    }\n    cout << n << \"的阶乘为：\";\n    for (j = num; j >= 1; j--)\n    {\n        cout << arr[j - 1];\n    }\n    cout << endl;\n    return 0;\n}\n```\n## 引用和函数\n```c\n#include<iostream>\nusing namespace std;\nvoid swap(int &a, int &b){\n\tint t;\n\tt=a;  a=b;  b=t;\n}\nint main(){\n\tint a=1,b=6;\n\tcout<<\"before swap:\\n\"<<\"a is:\"<<a\n\t\t<<\"  b is:\"<<b<<endl;\n\tswap(a,b);\n\tcout<<\"after  swap:\\n\"<<\"a is:\"<<a\n\t\t<<\"  b is:\"<<b<<endl;\n\treturn 0;\n}\n```\n## 函数的重载和默认参数\n```c\n#include <iostream>\nusing namespace std;\nvoid print(float y,char sex)\n{\n\tcout << (int)(y + 0.5) << \" years old,\" << (sex == 'M' ? \"male\" : \"female\") << endl;\n}\n\nvoid print(char sex,float y)\n{\n\tcout << (int)(y + 0.5) << \" years old,\" << (sex == 'M' ? \"male\" : \"female\") << endl;\n}\n\nvoid print()\n{\n\tcout<<\"0 years old,male\"<<endl;\n}\n\nint main(){\n\tfloat year;  char sex;\n\t//输入\n\tcin>>year>>sex;\n\tprint(year,sex);\n\tprint(sex,year);\n\tprint();           //这里输出0 years old， male，即默认是0岁，male\n\treturn 0;\n}\n```\n## 自己编写程序\n### 从键盘上读入两数，比较两个数的大小，并按从小到大的次序输出。（要求使用变量引用） \n```c\n#include <iostream>\n//（1）、从键盘上读入两数，比较两个数的大小，并按从小到大的次序输出。\n//（要求使用变量引用）\nusing namespace std;\n\nvoid input(int& x, int& y);\nvoid compare(int& x, int& y);\n\nint main()\n{\n\tint x, y;//利用变量引用输入x和y\n\tinput(x, y);//按照从小到大次序输出\n\tcompare(x, y);\n\treturn 0;\n}\n\nvoid input(int& x, int& y)\n{\n\tcout << \"输入x以及y：\";\n\tcin >> x >> y;\n}\n\nvoid compare(int& x, int& y)\n{\n\tx < y ? cout << x << \",\" << y << endl : cout << y << \",\" << x << endl;\n}\n\n```\n### 输出1到1000的素数，一行5个。\n```c\n#include <iostream>\n#include <cmath>\n#include <iomanip>\n//（2）、输出1到1000的素数，一行5个。\nusing namespace std;\nint main()\n{\n\tint count = 0;\n\tbool isPrime;\n\tfor (int i = 2; i < 1000; i++) {\n\t\tisPrime = true; \n\t\t//对于每一个i(i>=2)先假定为素数\n\t\tfor (int inside = 2; \n\t\t\tinside <= sqrt(i); \n\t\t\tinside++) {\n\t\t\tif (i % inside == 0) { \n\t\t\t\tisPrime = false; \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isPrime) {\n\t\t\tcout<<setw(4)<<i;\n\t\t\tif (++count % 5 == 0) {\n\t\t\t\t//每5个数换一行\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n### 编写一个C++风格的程序，解决百元问题：将一元人民币兑换成1、2、5分的硬币，有多少种换法？\n```c\n#include <iostream>\n//（3）、编写一个C++风格的程序，解决百元问题，有多少种换法？\nusing namespace std;\nint main()\n{\n\tint x, y, z;\t//1分、2分、5分的硬币数目分别用x、y、z表示\n\tint sum = 0;\t//换法计数器\n\tfor (z = 0; z <= 20; z++)\n\t\tfor (y = 0; y <= 50; y++)\n\t\t{\n\t\t\tfor (x = 0; x <= 100 - y - z; x++)\n\t\t\t{\n\t\t\t\tif (x + 2 * y + 5 * z == 100)\n\t\t\t\t{\t//cout << x << \",\" << y << \",\" << z << endl;\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << \"有\" << sum << \"种换法\" << endl;\n}\n```\n### 编写一个程序，建立一个上sroot（）的函数，返回其参数的二次方根。要求使用重载函数，重载3次，让其返回整数、长整数与双精度数的二次方根。\n```c\n#include <iostream>\n//（4）、编写一个程序，建立一个上sroot（）的函数，返回其参数的二次方根。\n//\t\t要求使用重载函数，重载3次，让其返回整数、长整数与双精度数的二次方根。\nusing namespace std;\ndouble sroot(int num);\ndouble sroot(long num);\ndouble sroot(double num);\n\nint main()\n{\n\tcout << sroot(10) << endl;\n\tcout << sroot(20L) << endl;\n\tcout << sroot(30.0) << endl;\n}\n\ndouble sroot(int num)\n{\n\treturn sqrt(num);\n}\ndouble sroot(long num)\n{\n\treturn sqrt(num);\n}\ndouble sroot(double num)\n{\n\treturn sqrt(num);\n}\n```\n### 写C++风格的程序，用二分法求解f（x）=0的根。\n```c\n#include <iostream>\n#include<cmath>\n//（5）、写C++风格的程序，用二分法求解f（x）=0的根。\nusing namespace std;\nint main()\n{\n    float x0, x1, x2, func, fx1, fx2;\n    do\n    {\n        cout << \"输入范围：\" << endl;\n        cin >> x1 >> x2;\n        fx1 = sin(x1);\n        fx2 = sin(x2);\n    } while (fx1 * fx2 > 0);\n    do\n    {\n        x0 = (x1 + x2) / 2;\n        func = sin(x0);\n        if ((func * fx1) < 0)\n        {\n            x2 = x0;\n            fx2 = func;\n        }\n        else\n        {\n            x1 = x0;\n            fx1 = func;\n        }\n    } while (fabs(func) >= 1e-5);\n    cout << \"x = \" << x0 << endl;\n    return 0;\n}\n```\n### 编写一个程序，用动态分配空间的方法计算 Fibonacci数列的前20项并存储到动态分配的空间中。注：使用malloc和free来实现\n```c\n#include<iostream>\n#include <iomanip>\n//（6）、编写一个程序，用动态分配空间的方法计算\n//     Fibonacci数列的前20项并存储到动态分配的空间中。\n//\t\t注：使用malloc和free来实现\nusing namespace std;\n\nint main() {\n\tint* p = (int*)malloc(sizeof(int) * 20);\n\t*p = 0; //第一个数为0\n\t*(p + 1) = 1; //第二个数为1\n\tfor (int i = 2; i < 20; ++i) \n\t{\n\t\t*(p + i) = *(p + i - 1) + *(p + i - 2);\n\t}\n\tfor (int i = 0; i < 20; ++i) \n\t{\n\t\tcout << \"第\" <<setw(2)<< i + 1 << \"项：\";\n\t\tcout <<setw(4)<< *(p + i)<<\"\\t\\t\";\n\t\tif ((i + 1) % 2 == 0)\n\t\t{\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tcout << endl;\n\tfree(p);\n\treturn 0;\n}\n```\n\n# 运行截图：\n\n![C-FirstExp](1.png)![C-FirstExp](2.png)\n\n# 心得：\n\n<font size=3>&emsp;`main()`函数的返回值用于判断程序是否正常结束，通常，返回0表示程序正常结束。</br>&emsp;在Visual Studio 2019环境下，`main()`返回值可定义为void类型，但根据C99标准，`main()`的标准定义格式为：\n &emsp;`int main(void) `\n &emsp;或：\n&emsp;`int main(int argc,char *argv[]) `\n&emsp;`main()`函数也可以省略return 0，编译器会自动调用`exit(0)`来析构栈变量。\n&emsp;`using namespace std`也可以不写，但是这时想要使用`cout`或者`endl`等位于`std`命名空间下的，如果不引入`std`命名空间，那么需要使用作用域运算符`::`来说明命名空间来源，例如：`std::cout`或者`std::endl`</br>&emsp;在老的C89编译器之前使用C语言的for循环，不能再for循环的`表达式1`位置定义变量，只能写在for循环之前，而新标准之后的C++中，可以在for循环里定义变量，此时的变量作用域在for循环内部。\n</font>\n\n<center><font size=4>感谢阅读💗</font></center>","tags":["C++"],"categories":["C++实验"]},{"title":"Java身份证验证CardID类","url":"/2021/03/17/Java-CardID/","content":"\n<big><b><center><font color='red'>=====taoyyz小陶©版权所有=====</font></center></b></big>\n\n<font size=6><center>实验三 身份证号码验证及个人信息输出。</center></font>\n\n# 要求：\n输入身份证号码，进行三重验证，并且输出对应信息。\n<font size=3> 1、身份证验证主要包含：</br>&emsp;&emsp;1. 位数错误：正确应该为 18 位。</br>&emsp;&emsp;2. 字符错误：前面 17 个应该是数字，最后一位可以为‘X’或‘x’;</br>&emsp;&emsp;3. 校验码错误：\n   &emsp;&emsp;&emsp;&emsp;身份证的最后一位为校验码，校验码是用于验证前面的数字是否有错误，校\n   验码运算规则：\n   &emsp;&emsp;&emsp;&emsp;（1）先将最后一位设定为 0。\n   &emsp;&emsp;&emsp;&emsp;（2）效验码的计算公式为：(Σ (ai×wi))%11\n    &emsp;&emsp;其中：i 是从右向左的包括效验码在内的序号（1－18）\n    &emsp;&emsp;ai 是第 i 位的数字\n    &emsp;&emsp;wi 是第 i 位上的加权因子，其数值依据公式 wi=(2(i-1))%11，（计算 ab：函数为：java.lang.Math.pow(a,b)） i，ai，wi 的对应关系如下：\n\n```\n身份证号码： 5  1  0  1  0  1  1  9  8  8 0 8 0 8 0 1 2 0\n    i    ：18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n    wi   ： 用公式计算 2^(i-1)%11 …… 9 10 5 8 4 2 1\n```\n&emsp;&emsp;&emsp;&emsp;（3）求出(Σ (ai×wi))%11 之后依据下表得到效验码：\n```\n(Σ (ai×wi))%11 :0 1 2 3 4 5 6 7 8 9 10\n        校验码值:1 0 X 9 8  7 6 5 4 3 2\n```\n&emsp;&emsp;&emsp;&emsp;（4）计算 ab：函数为：java.lang.Math.pow(a,b)\n2、个人信息输出主要包含：\n&emsp;&emsp;1: 生日：如 1985 年 5 月 9 日。\n&emsp;&emsp;2: 年龄：如 20 岁，应当精确到日；\n&emsp;&emsp;3: 性别：顺序码的计数为，男性以奇数计数，女性以偶数计数</font>\n<font size=2>&emsp;&emsp;&emsp;&emsp;（1）编写一个身份证类，包含一个属性：身份证号；三个验证函数；一个信息输出函数。\n&emsp;&emsp;&emsp;&emsp;（2）编写一个测试类，可从键盘上输入一个身份证号码，产生一个身份证对象，然后调用其相关方法对身份证号码进行验证，没有通过验证的话，提示错\n误信息并让用户重新输入，如果通过验证，则输出该人的信息。\n代码框架如下：\n\n```\nclass CardID{\n    private String cardNum; \n    public void setCardNum(String cardNum){//换一个号码\n        this. cardNum= cardNum; }\n    public boolean lengthVerify(){○1 位数错误验证\n    }\n    public boolean charVerify(){○2 字符错误验证\n    }\n    public boolean checkcodeVerify(){○3 校验码错误验证\n    //测试时请将每一轮的 i,ai,wi,sum 输出，避免出错，成功后不再输出\n    }\n    public void output(){○4 信息输出\n    //按要求输出个人信息\n    }\n}\nclass CardIDDemo{\n    public static void main(String []args){\n    //用死循环反复测试输入、验证、输出\n    //注意第一步验证失败不能进入第二步，第二步失败不能进入第三步，所有验\n    证通过才能进行输出。\n    }\n}\n```\n</font>\n\n# 思路：\n\n需要两个类：Card类和CardID类\n其中:1.在Card类中定义String类型的cardNum变量\n&emsp;&emsp;2.在Card类中定义Getter/Setter方法\n&emsp;&emsp;3.在Card类中定义3种验证方法：\n&emsp;&emsp;&emsp;&emsp;3.1对于位数验证，直接判断输入的cardNum长度是否为18\n&emsp;&emsp;&emsp;&emsp;3.2对于字符验证，前17位为数字，最后一位还可以为大小写的'x'\n&emsp;&emsp;&emsp;&emsp;3.3对于校验码，需要取出每一位，转化为整形进行算术运算\n&emsp;&emsp;4.在output()输出方法中，输出生日、年龄、性别\n&emsp;&emsp;5.以上3种输出需求均在身份证号码中截取获得\n&emsp;&emsp;6.利用Calendar类不是必须的，但是逻辑清晰，有利于日期计算\n&emsp;&emsp;7.年龄判断不是简单的相减，需要考虑到月份和天数不够减情况下的处理\n# 代码：\n\n```c CardID类：\npackage com.experiment.exp3;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Objects;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/3/3 15:25\n * @Version 1.0\n */\npublic class CardID {\n    private String cardNum;\n\n    public void setCardNum(String cardNum) {\n        this.cardNum = cardNum;\n    }\n\n    //位数错误验证 （是否为18位）\n    public boolean lengthVerify() {\n        if (this.cardNum.length() == 18) {\n            return true;\n        } else {\n            System.out.print(\"位数验证错误！\");\n            return false;\n        }\n    }\n\n    //字符错误验证（前17位为数字，最后一位为'X'或'x'）\n    public boolean charVerify() {\n        char[] chars = this.cardNum.toCharArray();\n        for (int i = 0; i < chars.length - 1; i++) {\n            if (!('0' <= chars[i] && chars[i] <= '9')) {\n                System.out.print(\"字符验证错误！\");\n                return false;\n            }\n        }\n        if (('0' <= chars[17] && chars[17] <= '9') || chars[17] == 'x' || chars[17] == 'X') {\n            return true;\n        } else {\n            System.out.print(\"字符验证错误！\");\n            return false;\n        }\n    }\n\n    //校验码错误验证 （最后一位）\n    public boolean checkCodeVerify() {\n        //先把输入的字符串类型身份证号转为字符串数组\n        String[] cardNumStr = numStringToArray();\n        //定义整型数组ai，以存放身份证号每一位的整型值，方便算术运算\n        int[] ai = new int[18];\n        //先把最后一位设定为0\n        ai[ai.length - 1] = 0;\n        //把身份证号除最后一位外，依次存入整型数组ai中（因为最后一位可能为字符'x'或'X'）\n        for (int i = 0; i < cardNumStr.length - 1; i++) {\n            ai[i] = Integer.parseInt(cardNumStr[i]);\n        }\n        int[] wi = new int[18];\n        //计算wi[]数组每一位\n        for (int i = ai.length; i > 0; i--) {\n            wi[18 - i] = (int) Math.pow(2, (i - 1)) % 11;\n        }\n        //计算校验码 verifyCode = (∑(ai x wi))%11\n        int result = 0;\n        for (int i = 0; i < ai.length; i++) {\n            result += ai[i] * wi[i];\n        }\n        int verifyCode = result % 11;\n        //定义一个字符串数组，存储每一位校验码应该对应的校验码值\n        String[] verifyCodeList = {\"1\", \"0\", \"X\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\"};\n        //判断校验码是否正确\n        String lastChar = verifyCodeList[verifyCode];\n        System.out.println(\"身份证最后一位应该是\" + \"'\" + lastChar + \"'\");\n        //注意在判断时，校验码数组只有大写的'X'，用户输入的可能为小写，会导致误判。应该都转为小写/大写再判断\n        if (Objects.equals(cardNumStr[cardNumStr.length - 1].toLowerCase(), lastChar.toLowerCase())) {\n            return true;\n        } else {\n            System.out.println(\"校验码验证错误！\");\n            return false;\n        }\n    }\n\n    //信息输出\n    public void output() {\n        /*\n            生日 第7位到第10位年 第11位到第12位月 第13位到第14位日    yyyy年M月d日\n            年龄 今天 - 生日    精确到日\n            性别 第15到17位    奇数男 偶数女\n        */\n        /*调用相应的方法计算生日、年龄、性别*/\n//        生日\n        //格式化Calendar类的生日为指定格式\n        Calendar birthDate = calcBirth();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年M月d日\");   //格式化时间成字符串\n        String birth = sdf.format(birthDate.getTime());\n//        年龄\n        String age = calcAge(birthDate);\n//        性别\n        String sex = calcSex();\n\n        //输出计算出的生日、年龄、性别\n        System.out.println(\"生日：\" + birth);\n        System.out.println(\"年龄：\" + age);\n        System.out.println(\"性别：\" + sex);\n        System.out.println(\"===========\");\n    }\n\n    //计算性别\n    private String calcSex() {\n\n        int numOfSex = Integer.parseInt(this.cardNum.substring(14, 17));\n        return numOfSex % 2 != 0 ? \"男\" : \"女\";\n    }\n\n    //计算年龄\n    private String calcAge(Calendar birthDateString) {\n        //解析生日到单独的变量中\n        int yearOfBirth = birthDateString.get(Calendar.YEAR);\n        int monthOfBirth = birthDateString.get(Calendar.MONTH) + 1;\n        int dayOfBirth = birthDateString.get(Calendar.DATE);\n        //获取今天的日期到单独变量中\n        Calendar nowDate = Calendar.getInstance();\n        int yearOfNow = nowDate.get(Calendar.YEAR);\n        int monthOfNow = nowDate.get(Calendar.MONTH) + 1;\n        int dayOfNow = nowDate.get(Calendar.DATE);\n        //计算年份差\n        int ageOfYear = yearOfNow - yearOfBirth;\n        //计算月份差\n        int ageOfMonth = monthOfNow - monthOfBirth;\n        if (ageOfMonth < 0) {    //今年的月份比出生月份小\n            ageOfYear--;         //年龄 - 1\n            ageOfMonth += 12;    //月份补12个月\n        }\n        //计算天数差\n        int ageOfDay = dayOfNow - dayOfBirth;\n        if (ageOfDay < 0) {     //天数比生日天数小\n            ageOfMonth--;       //月份 - 1\n            ageOfDay += nowDate.getActualMaximum(Calendar.DAY_OF_MONTH) + 1; //天数补齐一个月\n            /*这里有个小争议：如果活了某个月的最大天数，也可以算作活了这个月的下个月的第0天\n            对于某人的生日来说，+1 操作相当于把今天看做为新的一岁的第0天，而不是活了11月30天(因为活了12个月相当于就是下一年了)\n            加不加1就看怎么理解今天作为生日的话，到底是把今天算作这一岁的最后一天还是下一岁新的一天*/\n        }\n        //再次修正月份以及年份\n        if (ageOfMonth < 0) {   //上一步计算天数时，可能导致原本0月自减1变成-1\n            ageOfYear--;        //修正岁数 - 1\n            ageOfMonth += 12;   //月份补12个月\n        }\n        return ageOfYear + \"岁\" + ageOfMonth + \"月\" + ageOfDay + \"天\";\n    }\n\n    //计算生日\n    private Calendar calcBirth() {\n        //从输入的身份证号获取相应位置的字符串，转换成整数型\n        int year = Integer.parseInt(this.cardNum.substring(6, 10));   //注意substring()下标[begin,end)\n        int month = Integer.parseInt(this.cardNum.substring(10, 12));\n        int day = Integer.parseInt(this.cardNum.substring(12, 14));\n        Calendar birthDate = Calendar.getInstance();\n        //把Calendar类的birthDate设置为获取到的整数型的年、月、日\n        birthDate.set(Calendar.YEAR, year);\n        birthDate.set(Calendar.MONTH, month - 1);   //Calendar类月份从0到11月，实际上的8月只是MONTH的7月\n        birthDate.set(Calendar.DATE, day);\n        //把计算出来的birthDate作为Calendar类返回值带回\n        return birthDate;\n    }\n\n    //把输入的身份证字符串转化为字符串数组\n    private String[] numStringToArray() {\n        char[] chars = this.cardNum.toCharArray();\n        String[] numArray = new String[cardNum.length()];\n        for (int i = 0; i < cardNum.length(); i++) {\n            numArray[i] = String.valueOf(chars[i]);   //身份证号每一位的字符顺序存入int数组\n        }\n        return numArray;\n    }\n}\n\n```\n\n```c CardIDDemo类(含main方法)：\npackage com.experiment.exp3;\n/*\n    （1）编写一个身份证类，包含一个属性：身份证号；三个验证函数；一个\n    信息输出函数。\n    （2）编写一个测试类，可从键盘上输入一个身份证号码，产生一个身份证\n    对象，然后调用其相关方法对身份证号码进行验证，没有通过验证的话，提示错\n    误信息并让用户重新输入，如果通过验证，则输出该人的信息。\n    1。用死循环反复测试输入、验证、输出\n    2。注意第一步验证失败不能进入第二步，第二步失败不能进入第三步，所有验证通过才能进行输出。\n */\n\nimport java.util.Scanner;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/3/3 15:31\n * @Version 1.0\n */\npublic class CardIDDemo {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            System.out.println(\"请输入一个身份证号：\");\n            String cardId = sc.next();      //键盘输入一个身份证号码\n            CardID cardID = new CardID();   //产生一个身份证对象\n            //开始验证\n            cardID.setCardNum(cardId);\n            if (cardID.lengthVerify()) {    //位数错误验证\n                if (cardID.charVerify()) {  //字符错误验证\n                    if (cardID.checkCodeVerify()) { //校验码错误验证\n                        System.out.println(\"验证通过\");\n                        cardID.output();\n                    } else {\n                        error();\n                    }\n                } else {\n                    error();\n                }\n            } else {\n                error();\n            }\n        }\n    }\n\n    public static void error() {\n        System.out.println(\"验证错误，请重新输入\");\n        System.out.println(\"-----------\");\n    }\n}\n\n```\n\n# 运行截图：\n\n![CardID01](CardID01.png)![CardID02](CardID02.png)\n\n\n# 心得：\n\n<font size=3>&emsp;&emsp;这个CardID类考验面向对象的综合能力，特别是成员方法，如何进行三重验证。其次就是多次用到字符串截取：String类的<code>substring()</code>方法</br>&emsp;&emsp;在年龄计算那一块，精确到年很简单，属于有手就行。精确到月也只是多一步判断，就是当前月份-出生月份为负数时，说明当前月份比出生月份小，那么年龄就要-1，然后修正月份，也就是月份+=12。\n&emsp;&emsp;天数的处理跟上一步类似。要注意天数相减为负数时导致月份-1，这时候还需要再次判断月份是否为负。否则会导致原本0月，经过天数不够减之后，月份成为负1月。\n\n</font>\n\n<center><font size=4>感谢阅读💗</font></center>","tags":["Java"],"categories":["Java实训题"]},{"title":"Java复数Complex类","url":"/2021/03/15/Java-Complex/","content":"\n<big><b><center><font color='red'>=====taoyyz小陶©版权所有=====</font></center></b></big>\n\n<font size=6><center>实验二 定义一个复数类，并实现以下复数类的方法</center></font>\n\n# 要求：\n&emsp;&emsp;定义一个复数类，并实现以下复数类的方法：构造方法、得到实部、得到虚部。\n<font size=3> 1、复数类 Complex 必须满足如下要求：\n(1) 复数类 Complex 的属性有：\nrealPart : double 型 ，私有属性，代表复数的实数部分\nimaginPart : double 型 ，私有属性，代表复数的虚数部分11\n\n(2) 复数类 Complex 的构造方法有：\nComplex( ) : 构造函数，将复数的实部和虚部都置 0。\nComplex( double r , double i ) : 构造函数，形参 r 为实部的初值，i 为虚部的初值。\n\n(3) 复数类 Complex 的公有方法有：\nvoid setReal(): 设置复数对象的实部值；\nvoid setImagin (): 设置复数对象的虚部值；\ndouble getReal(): 获得复数对象的实部数值；\ndouble getImagin (): 获得复数对象的虚部数值；\n\nComplex complexAdd(Complex a) : 将当前复数对象与形参复数对象相加，所得的结果仍是一个复数值，返回给此方法的调用者。\n说明：（a+bi）+(c+di)= (a+c)+(b+d)i\n\nComplex complexSub(Complex a) : 将当前复数对象与形参复数对象相减，所得的结果仍是一个复数值，返回给此方法的调用者。\n\nComplex complexMulti(Complex a) : 将当前复数对象与形参复数对象相乘，所得的结果仍是一个复数值，返回给此方法的调用者。\n说明：（a+bi）(c+di)=ac+bci+adi+bdi2=(ac-bd)+(bc+ad)i\n\nComplex complexDiv(Complex a) : 将当前复数对象与形参复数对象相除，所得的结果仍是一个复数值，返回给此方法的调用者。\n说明：复数相除其实采用的是分子分母同时乘以分母的共轭复数，用以将分母的虚部消除掉，除法可调用乘法进行计算更简便。\n\nboolean equals(Complex a) : 将当前复数对象与形参复数对象进行比较，判断是否相等，返回一个布尔值。\n\nString toString( ) : 把当前复数对象的实部、虚部组合成 a+bi 的字符串形式，其中 a 和 b 分别为实部和虚部的数据，注意特殊数值的情况，如实部为 0、虚部为负，等等情况的表现方法。\n\n常见复数的写法有：3+2i，3-2i，4+i，4-i，1，0，-2i，i，-i 等(应当编写一个数组，存入以上9个复数，然后循环一次性全部输出，便于检查)。 \n\n2、定义个 ComplexDemo 类：\n    该类是程序的入口，要求能在主方法中创建至少 3 个复数（两个做操作数，通过键盘输入实部和虚部创建，一个做结果，不需实部和虚部），然后调用上述方法进行运算，并打印相应结果进行观察。</font>\n\n# 思路：\n\n\t两个类：Complex和ComplexDemo\n\t其中：1.在Complex类中定义复数的实部和虚部，double型。\n\t\t 2.定义Getter/Setter方法\n\t\t 3.定义复数的加减乘除方法，返回值是Complex类，返回给此方法的调用者。\n\t\t //对于3.也就是说谁调用的 加减乘除，结果返回给这个调用者，改变其值\n\t\t 4.定义equals()方法和toString()方法\n\t\t //对于equals()方法，比较两个Complex类的实部和虚部是否相同\n\t\t //对于toString()方法，遇到特殊情况(例如实部/虚部)为0，简化输出\n\t\t //对于toString()方法，当虚部为1/-1时，简化掉1，保留i以及符号\n\t\t 5.在主方法中创建3个复数，其中2个通过键盘输入实部和虚部，进行运算\n\t\t 6.toString()方法的检验可以通过存入多种极端情况测试简化效果\n\n# 代码：\n\n```c Complex类：\npackage com.experiment.exp2;\n\nimport java.text.DecimalFormat;\nimport java.util.Scanner;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/3/3 1:07\n * @Version 1.0\n */\npublic class Complex {\n    private double realPart;\n    private double imaginPart;\n\n    public Complex() {\n    }\n\n    public Complex(double r, double i) {\n        this.realPart = r;\n        this.imaginPart = i;\n    }\n\n/*    public Complex(String string) {       //随意以字符串输入复数，例如3+4i，但是实现起来太复杂了暂时没时间写了\n        boolean isRealPart=true;\n        char[] chars = string.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i]=='+'||chars[i]=='-'){\n                continue;\n            } else {\n                if (isRealPart) {\n                    this.realPart=chars[i];\n                }\n            }\n        }\n    }*/\n\n    public double getReal() {\n        return realPart;\n    }\n\n    public void setReal(double realPart) {\n        this.realPart = realPart;\n    }\n\n    public double getImagin() {\n        return imaginPart;\n    }\n\n    public void setImagin(double imaginPart) {\n        this.imaginPart = imaginPart;\n    }\n\n    public Complex complexAdd(Complex a) {      //复数的加法\n        this.realPart += a.realPart;\n        this.imaginPart += a.imaginPart;\n        return this;\n    }\n\n    public Complex complexSub(Complex a) {      //复数的减法\n        this.realPart -= a.realPart;\n        this.imaginPart -= a.imaginPart;\n        return this;\n    }\n\n    public Complex complexMulti(Complex a) {    //复数的乘法\n        double r, i;\n        r = (this.realPart * a.realPart - this.imaginPart * a.imaginPart);\n        i = (this.imaginPart * a.realPart + this.realPart * a.imaginPart);\n        return new Complex(r, i);\n    }\n\n    public Complex complexDiv(Complex a) {  //复数的除法\n        //注意除数的实部和虚部不能同时为0，否则会导致除法运算时分母为0出错\n        while (a.realPart == 0 && a.imaginPart == 0) {\n            System.out.println(\"除数的实部和虚部不能同时为0，请重新输入\");\n            System.out.println(\"重新输入除数的实部：\");\n            a.realPart = new Scanner(System.in).nextDouble();\n            System.out.println(\"重新输入除数的虚部：\");\n            a.imaginPart = new Scanner(System.in).nextDouble();\n        }\n        double r, i;\n        r = (this.realPart * a.realPart + this.imaginPart * a.imaginPart) /\n                (Math.pow(a.realPart, 2) + Math.pow(a.imaginPart, 2));\n        i = (this.imaginPart * a.realPart - this.realPart * a.imaginPart) /\n                (Math.pow(a.realPart, 2) + Math.pow(a.imaginPart, 2));\n        return new Complex(r, i);\n    }\n\n    public Complex ConjugateComNum() { //返回共轭复数\n        this.imaginPart *= -1;\n        return this;\n    }\n\n    public boolean equals(Complex a) {\n        if (this == a) return true;\n        if (a == null || getClass() != a.getClass()) return false;\n        return this.realPart == a.realPart && this.imaginPart == a.imaginPart;\n    }\n\n    @Override\n    public String toString() {\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String rp = df.format(this.realPart);\n        String ip = df.format(this.imaginPart);\n        String result = \"\";\n        if (this.realPart != 0) {\n            if (this.imaginPart == 0)\n                result = rp;\n            else if (this.imaginPart == 1)\n                result = rp + \"+i\";\n            else if (this.imaginPart == -1)\n                result = rp + \"-i\";\n            else if (this.imaginPart > 0)\n                result = rp + \"+\" + ip + \"i\";\n            else\n                result = rp + ip + \"i\";\n        } else {\n            if (this.imaginPart == 0)\n                result = \"0\";\n            else if (this.imaginPart == 1)\n                result = \"i\";\n            else if (this.imaginPart == -1)\n                result = \"-i\";\n            else\n                result = ip + \"i\";\n        }\n        return result;\n    }\n\n    /*@Override\n    public String toString() {\n        //保留两位小数\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String formatRealPart = df.format(this.realPart);\n        String formatImaginPart = df.format(this.imaginPart);\n        //处理虚部符号 正负\n        String symbol;\n        if (imaginPart >= 0) {\n            symbol = \"+\";\n        } else {\n            symbol = \"\";\n        }\n        //实部为0\n        if (realPart == 0) {\n            //虚部也为0\n            if (imaginPart == 0) {\n                return \"0\";\n            }\n            //实部为0，虚部不为0且为整数\n            if (imaginPart % 1 == 0) {\n                if (imaginPart == 1) {\n                    return \"i\";\n                }\n                if (imaginPart == -1) {\n                    return \"-i\";\n                }\n                return symbol + (int) imaginPart + \"i\";\n            }\n            //虚部不为整数时\n            return symbol + formatImaginPart + \"i\";\n        }\n        //否则实部不为0\n        //虚部为0，实部不为0\n        if (imaginPart == 0) {\n            //实部为整数\n            if (realPart % 1 == 0) {\n                return String.valueOf((int) realPart);\n            }\n            //实部不为整数\n            return formatRealPart;\n        }\n\n        //实部和虚部都不为0\n        //实部为整数\n        if (realPart % 1 == 0) {\n            //虚部也为整数\n            if (imaginPart % 1 == 0) {                                      //实部和虚部都为整数\n                if (imaginPart == 1) {\n                    return (int) realPart + symbol + \"i\";                   //虚部为1\n                }\n                if (imaginPart == -1) {                                     //虚部为-1\n                    return (int) realPart + \"-i\";\n                }\n                return (int) realPart + symbol + (int) imaginPart + \"i\";    //实部和虚部都为整数\n            } else {\n                return (int) realPart + symbol + formatImaginPart + \"i\";    //实部为整数，虚部不为整数\n            }\n            //实部不为整数\n        } else if (imaginPart % 1 == 0) {\n            return formatRealPart + symbol + (int) imaginPart + \"i\";         //只有虚部为整数\n        } else {\n            return formatRealPart + symbol + formatImaginPart + \"i\";         //实部和虚部都不为整数\n        }\n    }*/\n}\n\n```\n```c ComplexDemo类(含main方法)：\npackage com.experiment.exp2;\n\n/*\n    定义个 ComplexDemo 类：\n    该类是程序的入口，要求能在主方法中创建至少 3 个复数\n    （两个做操作数，通过键盘输入实部和虚部创建，一个做结果，不需实部和虚部）\n    ，然后调用上述方法进行运算，并打印相应结果进行观察。\n */\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/3/3 1:16\n * @Version 1.0\n */\npublic class ComplexDemo {\n    public static void main(String[] args) {\n        Complex result = new Complex(); //创建一个复数对象 作为结果 不需要实部和虚部\n        printComplexArray();\n        while (true) {\n            System.out.println(\"  1. add()\");\n            System.out.println(\"  2. sub()\");\n            System.out.println(\"  3. multi()\");\n            System.out.println(\"  4. div()\");\n            System.out.println(\"  5. 退出程序\");\n            System.out.print(\"选择操作：\");\n            int i = new Scanner(System.in).nextInt();\n            switch (i) {\n                case 1:\n                    add();\n                    break;\n                case 2:\n                    sub();\n                    break;\n                case 3:\n                    multi();\n                    break;\n                case 4:\n                    div();\n                    break;\n                case 5:\n                    return;\n            }\n            System.out.println(\"===================\");\n        }\n\n//        add();\n//        sub();\n//        multi();\n//        div();\n    }\n\n    public static ArrayList<Complex> input() {\n        //创建集合方便存放多个复数对象\n        ArrayList<Complex> arrayList = new ArrayList<>();\n        //通过键盘输入两个复数\n        for (int i = 0; i < 2; i++) {\n            arrayList.add(inputComplex(i + 1));\n        }\n        return arrayList;\n    }\n\n    public static void add() {\n        ArrayList<Complex> arrayList = input();\n        //加法运算  仅适用于2个复数相加\n        System.out.println(arrayList.get(0) + \" + \" + arrayList.get(1) + \" = \"\n                + arrayList.get(0).complexAdd(arrayList.get(1)));\n    }\n\n    public static void sub() {\n        ArrayList<Complex> arrayList = input();\n        //减法运算  仅适用于2个复数相减\n        System.out.println(arrayList.get(0) + \" - \" + arrayList.get(1) + \" = \"\n                + arrayList.get(0).complexSub(arrayList.get(1)));\n    }\n\n    public static void multi() {\n        ArrayList<Complex> arrayList = input();\n        //乘法运算  仅适用于2个复数相乘\n        System.out.println(arrayList.get(0) + \" * \" + arrayList.get(1) + \" = \"\n                + arrayList.get(0).complexMulti(arrayList.get(1)));\n    }\n\n    public static void div() {\n        ArrayList<Complex> arrayList = input();\n        //除法运算  仅适用于2个复数相除\n        System.out.println(arrayList.get(0) + \" ÷ \" + arrayList.get(1) + \" = \"\n                + arrayList.get(0).complexDiv(arrayList.get(1)));\n    }\n\n    public static Complex inputComplex(int seq) {\n        //输入复数的实部和虚部，产生一个复数并返回\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"请输入第\" + seq + \"个复数的实部：\");\n        double realPart = scanner.nextDouble();\n        System.out.print(\"请输入第\" + seq + \"个复数的虚部：\");\n        double imaginPart = scanner.nextDouble();\n        System.out.println(\"----------\");\n        return new Complex(realPart, imaginPart);\n    }\n\n    public static void printComplexArray() {\n        //存入9个复数对象 方便检查\n        ArrayList<Complex> complexes = new ArrayList<>(Arrays.asList(new Complex(3, 2), new Complex(3, -2),\n                new Complex(4, 1), new Complex(4, -1), new Complex(1, 0), new Complex(0, 0),\n                new Complex(0, -2), new Complex(0, 1), new Complex(0, -1)));\n        for (Complex complex : complexes) {\n            System.out.print(complex + \"  \");\n        }\n        System.out.println();\n    }\n}\n\n```\n\n# 运行截图：\n\n![Complex01](Complex01.png)![Complex02](Complex02.png)![Complex03](Complex03.png)\n\n\n# 心得：\n\n<font size=3>&emsp;&emsp;手动实现一个Complex类，想要做到严谨无Bug还是有一定的难度。对于强迫症患者来说，toString()方法就有够麻烦的了，而加减乘除方法可以通过百度查资料获得算术方法。</br>&emsp;&emsp;注意在乘除法处理时，上一条语句改变了realPart的值，在下一句又用到realPart值时会造成计算错误，所以这个时候需要一个中间变量来避免这种情况。</br>&emsp;&emsp;一般情况下对复数对象本身进行运算，并且返回给调用者时，可以直接`return this;`</font>\n<font size=3>&emsp;&emsp;CardID身份证类即将于下一期上线💗</font>","tags":["Java"],"categories":["Java实训题"]},{"title":"Java输出数字金字塔","url":"/2021/03/11/Java-DrawTriangle/","content":"\n<big><b><center><font color='red'>=====taoyyz小陶©版权所有=====</font></center></b></big>\n<font size=6><center>实验一 输出如下图形，行数通过键盘输入的数据确定</center></font>\n# 要求：\n&emsp;&emsp;用死循环反复测试，即把绘制函数放入`while()`循环中\n&emsp;&emsp;其实就是金字塔形，不过跟传统的那种输出*堆砌的金字塔不一样，这个奇数行是1，偶数行是2\n\n# 思路：\n\n个人分析：\n&emsp;&emsp;第一行1个元素              共计1个字符\n&emsp;&emsp;&emsp;&emsp;第二行2个元素+1个空格       共计3个字符\n&emsp;&emsp;&emsp;&emsp;第二行3个元素+2个空格       共计5个字符\n&emsp;&emsp;&emsp;&emsp;...\n&emsp;&emsp;&emsp;&emsp;第n行n个元素+(n-1)个空格    共计n+(n-1)个字符，即2n-1个字符\n\t\n&emsp;&emsp;对齐图形，只需要在第1行前面补(2n-1)/2个空格字符\n&emsp;&emsp;&emsp;&emsp;第2行前面补(2n-1)/2-1个空格字符\n&emsp;&emsp;&emsp;&emsp;第i行前面补(2n-1)/2-(i-1)个空格字符\n为了输出效果跟老师的一模一样，注意数字之间也要有空格分隔。\n\n# 代码：\n\n```c\npackage com.experiment.exp1.DrawTriangle;\n\nimport java.util.Scanner;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/3/2 21:37\n * @Version 1.0\n */\n\n/*\n    输出如下图形，行数通过键盘输入的数据确定：（用死循环反复测试）\n\n个人分析：\n    第一行1个元素              共计1个字符\n    第二行2个元素+1个空格       共计3个字符\n    第二行3个元素+2个空格       共计5个字符\n    ...\n    第n行n个元素+(n-1)个空格    共计n+(n-1)个字符，即2n-1个字符\n\n    对齐图形，只需要在第1行前面补(2n-1)/2个空格字符\n            第2行前面补(2n-1)/2-1个空格字符\n            第i行前面补(2n-1)/2-(i-1)个空格字符\n */\n\npublic class DrawTriangle {\n    public static void main(String[] args) {\n//        draw(); //调用即可输出一次\n        //题目要求死循环反复测试\n        while (true) {\n            draw();\n        }\n    }\n\n    //draw函数 接收一个金字塔的行数并输出\n    public static void draw() {\n        boolean isOddNum = true;\n        System.out.print(\"请输入金字塔层数：\");\n        int num = new Scanner(System.in).nextInt();         //接收金字塔层数\n        for (int i = 1; i <= num; i++) {                    //打印num层\n            for (int j = 0; j < (2 * num - 1) / 2 - (i - 1); j++) {\n                System.out.print(\" \");                      //对齐金字塔，前面补相应个空格\n            }\n            //单数层\n            if (isOddNum) {                                 //单数层输出1\n                System.out.print(1);\n                for (int printNum = 1; printNum < i; printNum++) {\n                    System.out.print(\" \" + 1);\n                }\n                isOddNum = false;                           //下次是双(复)数层\n                //双数层\n            } else {                                        //否则双(复)数层输出2\n                System.out.print(2);\n                for (int printNum = 1; printNum < i; printNum++) {\n                    System.out.print(\" \" + 2);\n                }\n                isOddNum = true;                            //下次是单数层\n            }\n            System.out.println();   //换行\n        }\n    }\n}\n\n```\n有个精简版，这里只展示`draw()`方法：\n```c\npublic static void draw() {\n        System.out.print(\"请输入金字塔层数：\");\n        int num = new Scanner(System.in).nextInt();   //接收金字塔层数\n        for (int i = 1; i <= num; i++) {              //打印num层\n            for (int j = i; j < num; j++) {\n                System.out.print(\" \");                //对齐金字塔，前面补相应个空格\n            }\n            for (int j = 1; j <= i; j++) {\n                System.out.print(i % 2 == 1 ? \"1 \" : \"2 \");\n            }\n            System.out.println();\n        }\n    }\n```\n# 运行截图：\n\n![JavaDrawTriangle01](JavaDrawTriangle01.png)\n\n\n# 心得：\n\n<font size=3>这种输出金字塔、菱形、正方形(最简单)、矩形等等的题，考虑嵌套循环。这道题需要考虑奇数层/偶数层 输出的数字是不同的。顺带一提，在输出 数字+\" \" 这种带空格的需要多次连接字符串，非常浪费性能，其实可以直接输出 \"数字 \" 这样一个字符串就解决了。但是现在编译器一般会自动优化成第二种格式。\n\n特别是对于菱形这种对称图形，在给定的\" * \"个数以内输出的话，可以先输出对称的其中一半，然后每次判断输出下一层还够不够。\n\n</font>\n<font size=3><center>💖💖💖这道题想做好就要动点脑子惹💖💖💖</center></font>\n\n<center><font size=4>感谢阅读💗</font></center>","tags":["Java"],"categories":["Java实训题"]},{"title":"Java输出素数","url":"/2021/03/11/Java-Prime/","content":"\n<big><b><center><font color='red'>=====taoyyz小陶©版权所有=====</font></center></b></big>\n<font size=6><center>实验一 输出 1,000,000 之内的所有素数</center></font>\n\n# 要求：\n&emsp;&emsp;程序简单，程序运行速度较快，行列对齐美观。\n# 思路：\n&emsp;&emsp;1. 只需判定2到根号i之间有无数可以让n被整除，能被2到sqrt(i)之间的数整除说明是合数，否则为素数\n&emsp;&emsp;2. 如果不注意上述这点，每次都循环2到n的话，当数字非常大的时候时间复杂度指数上升很可怕。\n&emsp;&emsp;3. 关于对齐：利用String类的format()方法格式化，并且每打印10个换一行\n\n# 代码：\n```c\npackage com.experiment.exp1;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/3/2 23:55\n * @Version 1.0\n */\n\npublic class PrimeNum {\n    public static void main(String[] args) {\n        printPrimeNum(1_000_000);\n    }\n\n    public static void printPrimeNum(int range) {\n        long start = System.currentTimeMillis();\n        boolean isPrime = false; //是否素数标志\n        int count = 0;  // 素数计数器\n\n        for (int i = 2; i < range; i++) {\n            if (2 > (int) Math.sqrt(i)) {\n                System.out.print(String.format(\"%8d\", i)); //利用String类的format()方法格式化字符串，固定宽度7，右对齐\n                count++;\n            }\n            //处理4到i的数\n            int num = (int) Math.sqrt(i);\n            //查看i是否能被2到num之间的某个数整除\n            for (int inside = 2; inside <= num; inside++) { //检查是否是素数\n                if (i % inside == 0) {  //能被整除说明不是素数\n                    isPrime = false;\n                    break;\n                } else {\n                    isPrime = true; //不能被整除就暂且判定是素数然后inside++，看能不能被下一位整数整除\n                }\n            }\n            //循环结束仍然是true，就打印这个素数\n            if (isPrime) {\n                System.out.print(String.format(\"%8d\", i));\n                if (++count % 8 == 0) {     //每8个数换一行\n                    System.out.println();\n                }\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"\\n素数个数：\" + count + \"消耗时间：\" + (end - start) + \"毫秒\");\n        //打印出素数结果  R7 4800H用时   IDEA≈600ms  cmd≈4s\n        //只统计素数个数  R7 4800H用时   IDEA≈300ms  cmd≈230ms\n    }\n}\n```\n# 运行截图：\n ![JavaPrime01](JavaPrime01.png)\n<center> 此处省略7万个素数</center>\n\n ![JavaPrime02](JavaPrime02.png)\n\n\n# 心得：\n&emsp;&emsp;<font size=3>可见，通过String类的`format()`方法进行格式化，配合每隔几个数就换行，整体排版还是比较整齐。并且由于内层只循环平方根次，所以即使是100万个数，仅耗时600ms，很🉑，所以一定要记得把O(n²)优化为O(n·logn)🍻</font>\n<center><font size=4>感谢阅读💗</font></center>","tags":["Java"],"categories":["Java实训题"]},{"title":"Java找成绩最大值最小值平均值","url":"/2021/03/10/Java-Count/","content":"\n<big><b><center><font color='red'>=====taoyyz小陶©版权所有=====</font></center></b></big>\n<font size=6><center>实验一 输入一系列成绩，输出最高分、最低分、平均分...</center></font>\n# 要求：\n&emsp;&emsp;输入输出格式正确，一重循环解决全部问题。\n&emsp;&emsp;输入一系列成绩，输出最高分、最低分、平均分，并统计存在多少个并列最高分，要求输入输出格式正确，一重循环解决全部问题。\n&emsp;&emsp;&emsp;&emsp;输入：`65 87 95 86 72 58 56 75 95 94 78…`\n&emsp;&emsp;&emsp;&emsp;输出：`最高分：95，最低分：56，平均分：72.36，同时存在 2 个并列最高分。`\n&emsp;&emsp;个人觉得题目里面的平均分是有问题的，计算器算出来也是78.27\n\n# 思路：\n\t一重循环，有手就行\n不过要注意输入格式，老师给的这个要求貌似是连续输入一串数字，以空格分开，那就考虑使用String类的split()方法来分割输入的字符串，返回值是个String[]字符数组。一会儿比较大小的时候利用包装类Integer的parseInt()方法转换成整型再比较。\n\n# 代码：\n\n```c\npackage com.experiment.exp1;\n\nimport java.util.Scanner;\n\n/**\n * @Author taoyyz(陶俊杰)\n * @Date 2021/3/2 16:12\n * @Version 1.0\n */\n/*\n    输入一系列成绩，输出最高分、最低分、平均分，并统计存在多少个并列最高分，要求输入输出格式正确，一重循环解决全部问题。\n    输入：65 87 95 86 72 58 56 75 95 94 78…\n    输出：最高分：95，最低分：56，平均分：72.36，同时存在 2 个并列最高分。\n    个人觉得题目里面的平均分是有问题的，计算器算出来也是78.27\n */\npublic class Count {\n    public static void main(String[] args) {\n        count();\n    }\n\n    private static void count() {\n        System.out.println(\"请输入一串成绩：\");\n        //输入一串数字,带空格用nextLine()读到回车结束\n        String[] scoreStr = new Scanner(System.in).nextLine().split(\" \");\n        //定义一个整型数组，用于把输入的数字字符串转为整型后存入\n        int[] scores = new int[scoreStr.length];\n        for (int i = 0; i < scoreStr.length; i++) {\n            scores[i] = Integer.parseInt(scoreStr[i]);\n        }\n        //定义最大值、最小值、平均数、并列最高分的计数器\n        int max = scores[0], min = scores[0], maxCount = 0;\n        double avg = 0;\n        //一重循环找出最大值、最小值、平均数、并列最高分出现的次数\n        for (int score : scores) {\n            if (max < score) {\n                max = score;\n                maxCount = 1;\n            } else if (max == score) {\n                maxCount++;\n            }\n            if (min > score) {\n                min = score;\n            }\n            avg += (double) score / scores.length;\n        }\n        //输出结果\n        System.out.println(\"最高分：\" + max + \",最低分：\" + min + \",平均分：\"\n                + String.format(\"%.2f\", avg) + \",同时存在\" + maxCount + \"个并列最高分\");\n    }\n}\n\n```\n\n# 运行截图：\n\n![JavaCount01](JavaCount01.png)\n\n\n# 心得：\n\n<font size=3>这种题是属于比较简单的循环问题。只需事先定义一个max、min、avg的值以及一个maxCount用于统计最大值出现了几次（这一点有点坑，要注意最大值变化之后计数器要重新计算）。</font>\n<font size=3>说白了有手就行，这都不会建议还是重修吧😅</font>\n\n<center><font size=4>感谢阅读💗</font></center>","tags":["Java"],"categories":["Java实训题"]}]